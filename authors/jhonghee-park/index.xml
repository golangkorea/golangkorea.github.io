<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang Korean Community</title>
    <link>https://golangkorea.github.io/authors/jhonghee-park/index.xml</link>
    <description>Recent content on Golang Korean Community</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://golangkorea.github.io/authors/jhonghee-park/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Golang의 내부, 6부: 부트스트래핑과 메모리 할당자</title>
      <link>https://golangkorea.github.io/post/golang-internals/part6/</link>
      <pubDate>Tue, 20 Sep 2016 16:20:29 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/golang-internals/part6/</guid>
      <description>

&lt;p&gt;이 포스트는 Golang 내부 시리즈의 연속이다. Go 런타임을 자세히 이해하는데 열쇠와 같은 부트스트랩 과정을 살펴볼 것이다. 이번에는 시작하는 순서의 두번째 부분을 섭렵해서 어떻게 인수들이 초기화되고, 어떤 함수들이 호출되는지 등을 배우겠다.&lt;/p&gt;

&lt;h1 id=&#34;시작하는-순서&#34;&gt;시작하는 순서&lt;/h1&gt;

&lt;p&gt;지난 번에 얘기하다가 만 &lt;em&gt;runtime.rt0_go&lt;/em&gt; 함수를 다시 다루어야 겠다. 아직 이 함수에서 살펴보지 않은 부분이 여전히 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;01 CLD                         // convention is D is always left cleared
02 CALL    runtime·check(SB)
03
04 MOVL    16(SP), AX          // copy argc
05 MOVL    AX, 0(SP)
06 MOVQ    24(SP), AX          // copy argv
07 MOVQ    AX, 8(SP)
08 CALL    runtime·args(SB)
09 CALL    runtime·osinit(SB)
10 CALL    runtime·schedinit(SB)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫번째 명령 (CLD)는 &lt;em&gt;FLAGS&lt;/em&gt; 레지스터의 &lt;a href=&#34;https://en.wikipedia.org/wiki/Direction_flag&#34;&gt;direction&lt;/a&gt; 프래그를 지운다. 이 플래그는 문자열 처리 방향에 영향을 준다.&lt;/p&gt;

&lt;p&gt;다음 함수는 &lt;em&gt;runtime.check&lt;/em&gt; 함수를 호출하는데, 그 또한 이 문서의 목적에 비추어 그리 중요하지는 않다. 런타임은 모든 내장 타입의 인스턴스들을 만들고, 타입의 크기와 파라미터들을 확인하는 정도의 일을 한다. 그리고 만약 작업중 문제가 생기면 &lt;em&gt;panic&lt;/em&gt; 한다. &lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/runtime1.go#L136&#34;&gt;function&lt;/a&gt;를 통해 쉽게 알아볼 수 있다.&lt;/p&gt;

&lt;h1 id=&#34;인수-분석하기&#34;&gt;인수 분석하기&lt;/h1&gt;

&lt;p&gt;그 다음 함수 &lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/runtime1.go#L48&#34;&gt;runtime.Args&lt;/a&gt; 는 좀 더 흥미롭다. The next function, 리눅스 시스템에서 (&lt;em&gt;argc&lt;/em&gt; 와 &lt;em&gt;argv&lt;/em&gt;) 인수를 정적 변수속에 저장하는 것말고도 이 함수는 ELF 보조 벡터를 분석하며 &lt;em&gt;syscall&lt;/em&gt; 주소를 초기화한다.&lt;/p&gt;

&lt;p&gt;설명이 좀 더 필요하겠다. 운영체계가 프로그램을 메모리에 올릴때, 그 프로그램의 초기 스택을 미리 정해진 포맷의 어떤 데이타로 초기화한다. 스택의 꼭대기에는 환경 변수들의 포인터인 인수들이 깔린다. 스택의 바닥에는 &amp;ldquo;ELF 보조 벡터&amp;rdquo;를 볼 수 인데, 실제로 이 것은 어떤 유용한 정보를 담고 있는 기록의 배열들이다. 예를 들면, 프로그램 헤더의 수와 크기들이다. 여기 이 &lt;a href=&#34;http://articles.manugarg.com/aboutelfauxiliaryvectors&#34;&gt;문서&lt;/a&gt;를 통해 ELF 보조 벡터 포맷에 대해 좀 자세히 알아 보라.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;runtime.Args&lt;/em&gt; 함수는 벡터를 파싱하는 책임이 있다. 런타임은 벡터에 담고 있는 모든 정보들 중에 단지 &lt;em&gt;startupRandomData&lt;/em&gt; 만을 사용하는데, 주로 헤싱 함수(hashing functions)들과 어떤 syscall들의 위치를 가리키는 포인터들을 초기화하는데 주로 사용된다. 다음에 나오는 변수들을 초기화한다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 __vdso_time_sym
2 __vdso_gettimeofday_sym
3 __vdso_clock_gettime_sym
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 것들은 여러 함수들내 현재 시간을 획득하는데 사용된다. 이 모든 변수들은 기본값을 가진다. 이렇게 함으로써 Golang에서 상응하는 함수들을 호출하기 위해 &lt;em&gt;&lt;a href=&#34;http://www.ukuug.org/events/linux2001/papers/html/AArcangeli-vsyscalls.html&#34;&gt;vsyscall&lt;/a&gt;&lt;/em&gt; 메카니즘의 사용이 허용된다.&lt;/p&gt;

&lt;h1 id=&#34;runtime-osinit-함수의-내부&#34;&gt;&lt;em&gt;runtime.osinit&lt;/em&gt; 함수의 내부&lt;/h1&gt;

&lt;p&gt;시작 순서에서 그 다음으로 호출되는 함수는 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/os1_linux.go#L172&#34;&gt;runtime.osinit&lt;/a&gt;&lt;/em&gt; 이다. 리눅스 시스템에서 단 한가지 하는 일이 있는데 그것은 시스템내 CPU 숫자를 가지고 있는 ncpu 변수를 한 syscall을 통해 초기화하는 것이다.&lt;/p&gt;

&lt;h1 id=&#34;runtime-schedinit-함수의-내부&#34;&gt;&lt;em&gt;runtime.schedinit&lt;/em&gt; 함수의 내부&lt;/h1&gt;

&lt;p&gt;시작 순서에서 다음 함수인 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/proc1.go#L40&#34;&gt;runtime.schedinit&lt;/a&gt;&lt;/em&gt; 는 더 흥미롭다. 현재의 고루틴을 얻는 것으로 시작하는데, 사실 이 것은 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/runtime2.go#L211&#34;&gt;g&lt;/a&gt;&lt;/em&gt; 구조의 포인터이다. 이미 이 포인터가 어떻게 저장되는 지는 TLS 구현을 논할 때 얘기한 바있다. 다음은 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/race1.go#L110&#34;&gt;runtime.raceinit&lt;/a&gt;&lt;/em&gt; 를 호출한다. runtime.raceinit에 대한 토론은 넘어가겠다. 왜냐하면 이 함수는 race 조건이 활성화되지 않은 경우는 보통 호출되지 않기 때문이다. 그 다음에는 몇몇 다른 초기화 함수들이 호출된다.&lt;/p&gt;

&lt;p&gt;하나씩 살펴보자.&lt;/p&gt;

&lt;h1 id=&#34;traceback-초기화&#34;&gt;traceback 초기화&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/traceback.go#L58&#34;&gt;runtime.tracebackinit&lt;/a&gt;&lt;/em&gt; 함수는 traceback을 초기화하는 일을 한다. Traceback이라는 것은 현재의 실행지점에 오기까지 호출된 함수들의 스택을 말한다. 예를 들어, panic이 일어날 때마다 볼 수 있다. Traceback은 주어진 프로그램 카운터로 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/traceback.go#L120&#34;&gt;runtime.gentraceback&lt;/a&gt;&lt;/em&gt; 함수를 호출함으로써 얻어진다. 이 함수가 동작하려면, 몇몇 내장함수들의 주소를 알 필요가 있는데, 그 이유는 traceback에 이 함수들이 나타나는 것을 원하지 않기 때문이다. 이 주소들은 &lt;em&gt;runtime.tracebackinit&lt;/em&gt; 을 통해 초기화된다.&lt;/p&gt;

&lt;h1 id=&#34;링커-심볼들-검사하기&#34;&gt;링커 심볼들 검사하기&lt;/h1&gt;

&lt;p&gt;링커 심볼들은 링커가 실행파일과 오브젝트 파일에 뿜어내는 데이터를 말한다. 대부분의 내용은 &lt;a href=&#34;https://golangkorea.github.io/post/golang-internals/part3/&#34;&gt;Golang의 내부, 3부: 링커, 오브젝트 파일, 그리고 재배치&lt;/a&gt;에서 논했다. runtime 패키지에서 링커 심볼들은 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/symtab.go#L37&#34;&gt;moduledata&lt;/a&gt;&lt;/em&gt; 구조체에 맵핑되어 있다. &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/symtab.go#L95&#34;&gt;runtime.moduledataverify&lt;/a&gt;&lt;/em&gt; 함수를 통해 이 데이타에 대한 확인이 이루어지고 오염여부와 구조가 바른지를 검사한다.&lt;/p&gt;

&lt;h1 id=&#34;스택-풀-초기화하기&#34;&gt;스택 풀 초기화하기&lt;/h1&gt;

&lt;p&gt;다음 초기화 단계를 이해하기 위해서는 Go 언어에서 스택이 어떻게 자라는지를 대한 지식이 조금 필요하다. 새로운 고루팅이 만들어 지면 작고 크기가 고정된 스택이 할당된다. 스택이 어떤 한계치에 도달하면, 크기가 두배가 되고 스택은 다른 장소로 복사된다.&lt;/p&gt;

&lt;p&gt;아직 살펴보아야 할 자세한 내용들로 어떻게 한계치에 도달했는지를 결정하는지, Go가 어떻게 스택내 포인터들을 조정하는지가 남아 있다. 이전 포스트에서 &lt;em&gt;stackguard0&lt;/em&gt; 필드와 함수 메타데이더를 얘기할 때 이런 주제에 대해 약간 다루기도 했다. 이 주제에 대해 유용한 정보는 &lt;a href=&#34;https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub&#34;&gt;이 문서&lt;/a&gt;를 통해 찾을 수 있다.&lt;/p&gt;

&lt;p&gt;Go는 현재 이용되지 않은 스택들을 저장하기 위해 스택 풀을 이용한다. 스택 풀은 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/stack1.go#L54&#34;&gt;runtime.stackinit&lt;/a&gt;&lt;/em&gt; 함수내 초기화된 배열이다. 이 배열안의 각 아이템은 같은 크기를 갖는 스택들의 linked list 구조를 담고 있다.&lt;/p&gt;

&lt;p&gt;이 단계에 초기화되는 또 다른 변수로 &lt;em&gt;runtime.stackFreeQueue&lt;/em&gt; 가 있다. 이것 역시 스택들로 이루어진 linked list를 담고 있지만, 가비지 컬렉션중에 리스트에 추가되며 끝나면 지워진다. 2 KB, 4 KB, 8 KB 그리고 16 KB 크기의 스택만이 저장되고 그 보다 큰 것들은 직접 할당되는 점을 주목하라.&lt;/p&gt;

&lt;h1 id=&#34;메모리-할당자-초기화하기&#34;&gt;메모리 할당자 초기화하기&lt;/h1&gt;

&lt;p&gt;메모리 할당 과정은 이 &lt;a href=&#34;(https://github.com/golang/go/blob/go1.5.1/src/runtime/malloc.go#L5)&#34;&gt;소스 코드 커밋&lt;/a&gt;에 서술되어 있다. 메모리 할당이 어떻게 작동하는지를 이해하고자 한다면 꼭 읽어 보길 권장한다. 이 주제는 앞으로 나올 포스트에서 더 자세히 다루도록 하겠다. 메모리 할당자의 초기화는 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/malloc.go#L216&#34;&gt;runtime.mallocinit&lt;/a&gt;&lt;/em&gt; 함수내 자리잡고 있다. 가까이 들여다 보자.&lt;/p&gt;

&lt;h1 id=&#34;사이즈-클래스들-size-classes-를-초기화하기&#34;&gt;사이즈 클래스들(size classes)를 초기화하기&lt;/h1&gt;

&lt;p&gt;여기에 처음 볼 수 있는 것은 &lt;em&gt;runtime.mallocinit&lt;/em&gt; 가 또 다른 함수-&lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/msize.go#L66&#34;&gt;initSizes&lt;/a&gt;&lt;/em&gt; 를 호출하는 것이다. 이 함수는 사이즈 클래스들를 계산하는 일을 한다. 하지만 클래스의 크기를 어떻게 결정하는가? (32 KB 가 안되는) 작은 객체를 할당할 때, Go 런타임은 처음 미리 정해둔 클래스 크기로 객체의 크기를 반올림한다. 그래서 할당된 메모리 블록은 실제 필요한 객체 크기보 보통 좀 더 큰, 미리 정해진 크기들중에 하나를 선택할 수 밖에 없다. 이로 인해 메모리가 조금 낭비되긴 하지만 이 방법을 통해서 다른 객체에 이미 할당된 메모리를 재사용하는 것이 용이해 진다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;initSizes&lt;/em&gt; 함수는 이런 클래스를 계산하는 일을 한다. 함수 꼭대기에서 다음 코드를 볼 수 있다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;01     align := 8
02     for size := align; size &amp;lt;= _MaxSmallSize; size += align {
03         if size&amp;amp;(size-1) == 0 {
04             if size &amp;gt;= 2048 {
05                 align = 256
06             } else if size &amp;gt;= 128 {
07                 align = size / 8
08             } else if size &amp;gt;= 16 {
09                 align = 16
10 …
11             }
12         }
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;보다시피 가장 작은 사이즈 클래스들은 8과 16 바이트이다. 그 다음 클래스는 128 바이트까지 16 바이트가 올라갈 때마다 위치해 있다. 128부터 2,048 바이트까지는 size/8 바이트마다 클래스가 위치해 있다. 2,048 바이트 이후에는 256 바이트마다 사이즈 클래스가 위치해 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;initSizes&lt;/em&gt; 메서드는 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/msize.go#L49&#34;&gt;class_to_size&lt;/a&gt;&lt;/em&gt; 배열을 초기화한다. 이 배열은 하나의 클래스(여기에서 크기라 함은 클래스 리스트내 서열을 의미한다)를 그 크기로 변환한다. 이 함수는 또 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/msize.go#L50&#34;&gt;class_to_allocnpages&lt;/a&gt;&lt;/em&gt; 배열을 초기화하는데 이 배열은 주어진 클래스의 객체를 채우기 위해 OS로 부터 얼마나 많은 메모리 페이지를 받아내야 하는가에 대한 데이터를 저장한다. 이외 배열을 두개 더-&lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/msize.go#L53&#34;&gt;size_to_class8&lt;/a&gt;&lt;/em&gt; 와 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/msize.go#L54&#34;&gt;size_to_class128&lt;/a&gt;&lt;/em&gt; 를 초기화한다. 이 두 배열은 객체 크기로 부터 상응하는 클래스 서열로 변환하는데 사용되는데 첫번째 것은 1 KB 보다 작은 객체의 크기를 변환하고, 두번째는 1-32 KB 크기의 객체에 대한 변환을 맡는다.&lt;/p&gt;

&lt;h1 id=&#34;가상-메모리-예약하기&#34;&gt;가상 메모리 예약하기&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;mallocinit&lt;/em&gt; 함수가 다음으로 하는 일은 미래에 있을 할당들을 위해 가상 메모리를 예약하는 것이다. x64 아키텍쳐에서 이것이 어떻게 구현되었는지 알아보자. 무엇보다도 우선 다음 변수들을 초기화해야 한다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 arenaSize := round(_MaxMem, _PageSize)
2 bitmapSize = arenaSize / (ptrSize * 8 / 4)
3 spansSize = arenaSize / _PageSize * ptrSize
4 spansSize = round(spansSize, _PageSize)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;arenaSize&lt;/em&gt; 은 객체 할당의 예약에 사용될 수 있는 가상 메모리의 최대치이다. 64비트 아키텍쳐에서는 512 GB에 해당한다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;bitmapSize&lt;/em&gt; 는 가비지 컬렉션 (GC) 비트맵을 위해 예약될 수 있는 메모리의 양에 상응한다. GC 비트맵은 특별한 메모리 타입으로 메모리에서 포인터들이 정확히 어디에 위치하는지를 보여주는데 사용되고 이 포인터들이 가리키는 객체들이 GC에 의해 표시(mark)될 것인지의 여부를 결정하는데 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;spansSize&lt;/em&gt; 는 모든 메모리 스팬(memory span)들을 가리키는 포인터들의 배열을 저장하기 위해 얼마나 많은 메모리를 예약되었는지를 나타낸다. 메모리 스팬은 객체 할당을 위해 사용된 메모리 블록를 둘러 싸는 구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 변수들이 모두 계산되면, 실제 예약이 끝나는 것이다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 pSize = bitmapSize + spansSize + arenaSize + _PageSize
2 p = uintptr(sysReserve(unsafe.Pointer(p), pSize, &amp;amp;reserved))
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;마침내, 모든 메모리에 상관된 객체들을 위한 중앙 저장소로 사용될 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L65&#34;&gt;mheap&lt;/a&gt;&lt;/em&gt; 전역 변수를 초기화 할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 p1 := round(p, _PageSize)
2
3 mheap_.spans = (**mspan)(unsafe.Pointer(p1))
4 mheap_.bitmap = p1 + spansSize
5 mheap_.arena_start = p1 + (spansSize + bitmapSize)
6 mheap_.arena_used = mheap_.arena_start
7 mheap_.arena_end = p + pSize
8 mheap_.arena_reserved = reserved
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;처음부터, &lt;em&gt;mheap_.arena_used&lt;/em&gt; 가 &lt;em&gt;mheap_.arena_start&lt;/em&gt; 와 동일한 주소를 가지고 초기화되었음을 주목하라. 이유는 아직 아무 것도 할당되지 않았기 때문이다.&lt;/p&gt;

&lt;h1 id=&#34;힢-heap-초기화&#34;&gt;힢(Heap) 초기화&lt;/h1&gt;

&lt;p&gt;다음으로 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L273&#34;&gt;mHeap_Init&lt;/a&gt;&lt;/em&gt; 함수가 호출된다. 할당자의 초기화가 제일 먼저 진행되었다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 fixAlloc_Init(&amp;amp;h.spanalloc, unsafe.Sizeof(mspan{}), recordspan, unsafe.Pointer(h), &amp;amp;memstats.mspan_sys)
2 fixAlloc_Init(&amp;amp;h.cachealloc, unsafe.Sizeof(mcache{}), nil, nil, &amp;amp;memstats.mcache_sys)
3 fixAlloc_Init(&amp;amp;h.specialfinalizeralloc, unsafe.Sizeof(specialfinalizer{}), nil, nil, &amp;amp;memstats.other_sys)
4 fixAlloc_Init(&amp;amp;h.specialprofilealloc, unsafe.Sizeof(specialprofile{}), nil, nil, &amp;amp;memstats.other_sys)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;할당자가 무엇인가를 더 잘 이해하기 위해서, 우선 어떻게 사용되는지 살펴보자. 모든 할당자는 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/mfixalloc.go#L54&#34;&gt;fixAlloc_Alloc&lt;/a&gt;&lt;/em&gt; 함수 내에서 운영된다. 이 함수는 다음과 같은 구조체의 새로운 할당이 필요할때 호출된다 - &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L101&#34;&gt;mspan&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/mcache.go#L11&#34;&gt;mcache&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L1009&#34;&gt;specialfinalizer&lt;/a&gt;&lt;/em&gt;, 그리고 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L1050&#34;&gt;specialprofile&lt;/a&gt;&lt;/em&gt;. 이 함수의 주요한 부분은:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 if uintptr(f.nchunk) &amp;lt; f.size {
2     f.chunk = (*uint8)(persistentalloc(_FixAllocChunk, 0, f.stat))
3     f.nchunk = _FixAllocChunk
4 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 부분은 메모리를 할당하지만 구조체의 실제 크기인 &lt;em&gt;f.size&lt;/em&gt; 바이트를 할당하는 대신 (현재는 16 KB)인 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/malloc.go#L130&#34;&gt;_FixAllocChunk&lt;/a&gt;&lt;/em&gt; 바이트를 따로 떼어 놓은다. 나머지 사용가능한 공간은 할당자내 저장된다. 다음번에 같은 타입의 구조체를 할당할 필요가 있으면 시간을 많이 소비하는 &lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/malloc.go#L828&#34;&gt;persistentalloc&lt;/a&gt;를 호출할 필요가 없게 된다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;persistentalloc&lt;/em&gt; 함수는 가비지 컬렉트되어서는 않되는 메모리를 할당하는 일을 한다. 이 함수의 웍플로우는 다음과 같다:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;만약 할당된 블록이 64 KB보다 크면 OS 메모리로 부터 직접 할당된다.&lt;/li&gt;
&lt;li&gt;그렇기 않은 경우는, 우선 지속성 할당자(persistent allocator)를 찾을 필요가 있다.

&lt;ul&gt;
&lt;li&gt;지속성 할당자는 각 프로세서에 부착되어 있다. 이유는 하나만 가지고 작업할 경우 locks을 사용해야 함을 피하기 위해서이다. 그래서 현재 프로세서에 부착된 지속성 할당자를 사용하고자 하는 것이다.&lt;/li&gt;
&lt;li&gt;만약 현재 프로세서의 정보를 얻을 수 없는 경우는, 전역 할당자 (global allocator)가 사용된다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;만약 할당자가 캐쉬에 사용가능한 메모리가 충분치 않을 경우는 OS로 부터 메모리를 더 가지고 온다.&lt;/li&gt;
&lt;li&gt;필요한 만큼의 메모리가 할당자의 캐쉬에서 반환된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;persistentalloc&lt;/em&gt; 과 &lt;em&gt;fixAlloc_Alloc&lt;/em&gt; 함수는 비슷하게 작동한다. 이 함수들은 두가지 레벨의 캐쉬를 구현하고 있다고 말할 수 있겠다. &lt;em&gt;persistentalloc&lt;/em&gt; 는 &lt;em&gt;fixAlloc_Alloc&lt;/em&gt; 에만 사용되는 것이 아니라 지속성 메모리(persistent memory)를 할당할 필요가 있는 여러 군데에서 사용되고 있다는 것을 숙지하여야 한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;mHeap_Init&lt;/em&gt; 함수로 다시 돌아가자. 답을 해야할 중요한 질문이 하나 더 있는데, 그것은 이 함수의 시작부분에서 할당자가 초기화되는 목적이었더 네개의 구조가 어떻게 사용되는지에 대한 것이다:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;mspan&lt;/em&gt; 는 가비지 컬렉트되어야 하는 메모리 블록을 감싸는 것이다. 사이즈 클래스들(size classes)을 논할 때 얘기했었다. 특정한 사이즈 클라스의 새로운 객체를 할당할 필요가 생겼을때 새로운 mspan이 만들어진다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;mcache&lt;/em&gt; 는 각 프로세서에 부착된 구조체이다. 메모리 스팬을 캐취에 저장하는 일을 한다. 프로세스마다 따로 캐쉬를 갖는 이유는 locking을 피하기 위해서 이다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;specialfinalizeralloc&lt;/em&gt; 는 &lt;em&gt;runtime.SetFinalizer&lt;/em&gt; 함수가 호출될 때 할당되는 구조체이다. 객체가 제거되면서 정리정돈(cleanup)하는 코드를 실행시키길 원한다면 이 구조체를 만들어야 할 것이다. 좋은 예제로 새로운 파일마다 finalizer를 연계시키는 &lt;em&gt;os.NewFile&lt;/em&gt; 함수이다. 이 finalizer가 OS 파일 설명자(file descriptor)를 닫아야 한다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;specialprofilealloc&lt;/em&gt; 는 메모리 프로파일러에 사용되는 구조체이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;메모리 할당자들을 초기화하고 난 후, &lt;em&gt;mHeap_Init&lt;/em&gt; 함수는 &lt;em&gt;&lt;a href=&#34;https://github.com/golang/go/blob/go1.5.1/src/runtime/mheap.go#L863&#34;&gt;mSpanList_Init&lt;/a&gt;&lt;/em&gt; 을 호출함으로서 리스트들을 초기화 한다. 간단한 일로 linked 리스트를 위한 첫번째 입력을 초기화하는 것이다. &lt;em&gt;mheap&lt;/em&gt; 구조체는 그러한 linked 리스트를 몇개 가지고 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;mheap.free&lt;/em&gt; 와 &lt;em&gt;mheap.busy&lt;/em&gt; 는 &lt;em&gt;free&lt;/em&gt; 와 &lt;em&gt;busy&lt;/em&gt; 리스트를 담고 있는 배열들로 대형(32 KB보다 크고, 1 MB보다 작은) 객체들을 위한 메모리 스팬을 갖고 있다. 각 배열은 가능한 크기의 아이템을 가지고 있다. 여기서 크기들은 페이지로 측정된다. 한 페이지는 32 KB에 해당한다. 첫번째 아이템은 32 KB 스팬을 가지는 리스트를 담고 있고, 두번째는 64 KB 스팬을 가지는 리스트를 담고 있는 그런 식이다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;mheap.freelarge&lt;/em&gt; 와 &lt;em&gt;mheap.busylarge&lt;/em&gt; 는 1 MB이상의 객체들을 위한 free 와 busy 리스트들이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음 단계는 &lt;em&gt;mheap.central&lt;/em&gt; 를 초기화하는 것인데, (32 KB 보다 작은) 소형 객체들을 위한 스팬들을 저장한다. &lt;em&gt;mheap.central&lt;/em&gt; 안에서는 리스트가 사이즈 클래스에 맞게 그룹을 형성한다. 초기화는 이제까지 우리가 본 것들과 유사하다. 단순히 각 free 리스트에 대한 linked 리스트를 초기화 하는 것이다.&lt;/p&gt;

&lt;h1 id=&#34;캐쉬의-초기화&#34;&gt;캐쉬의 초기화&lt;/h1&gt;

&lt;p&gt;이제 메모리 할당자 초기화에 대한 얘기가 거의 끝나간다. &lt;em&gt;mallocinit&lt;/em&gt; 함수내 마지막으로 남은 것은 mcache 초기화이다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 _g_ := getg()
2 _g_.m.mcache = allocmcache()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기를 보면, 우선 현재의 고루틴을 얻는다. 각 고루틴은 &lt;em&gt;m&lt;/em&gt; 구조체로 연결된 링크를 담고 있다. 이 구조체는 시스템 쓰레드를 감싸는 구조이다. 이 구조체의 내부에는 &lt;em&gt;mcache&lt;/em&gt; 라는 필드가 있는데 위에보면 초기화되고 있다. &lt;em&gt;allocmcache&lt;/em&gt; 함수는 &lt;em&gt;fixAlloc_Alloc&lt;/em&gt; 을 호출하여 새로운 &lt;em&gt;mcache&lt;/em&gt; 구조체를 초기화한다. 이미 어떻게 할당이 되었는지 이 구조체의 의미는 무엇인지에 대해서 논한 바 있다 (상위의 내용을 살펴보라).&lt;/p&gt;

&lt;p&gt;조심스런 독자는 저자가 &lt;em&gt;mcache&lt;/em&gt; 가 프로세스마다 부착되어 있다고 얘기한 걸 기억할 것이다. 그런데 이제 보니 프로세서(processor)가 아닌 OS 프로세스(process)에 상응하는 &lt;em&gt;m&lt;/em&gt; 구조체에 부착되어 있는 것이었다. 그게 맞는 말이다-mcache는 현재 실행중인 쓰레드에 대해서만 초기화되며 프로세스가 바뀔때(process switch) 마다 또 다른 쓰레드로 재배치된다.&lt;/p&gt;

&lt;h1 id=&#34;곧-추가될-go-부트스트래핑에-대한-포스트&#34;&gt;곧 추가될 Go 부트스트래핑에 대한 포스트&lt;/h1&gt;

&lt;p&gt;다음 포스트에서는 어떻게 가비지 컬랙터가 초기화되는지 긔고 어떻게 main 고루틴이 시작되는지를 살펴보며 부트스트랩 과정을 더 논하겠다. 그때까지 아래 코멘트란에 독자의 생각이나 의견을 공유하는데 주저하지 말라.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;원문: &lt;a href=&#34;http://blog.altoros.com/golang-internals-part-6-bootstrapping-and-memory-allocator-initialization.html&#34;&gt;Golang Internals, Part 6: Bootstrapping and Memory Allocator Initialization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;저자: Siarhei Matsiukevich&lt;/li&gt;
&lt;li&gt;번역자: Jhonghee Park&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golang의 내부, 5부: 런타임 부트스트랩</title>
      <link>https://golangkorea.github.io/post/golang-internals/part5/</link>
      <pubDate>Mon, 19 Sep 2016 16:20:29 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/golang-internals/part5/</guid>
      <description>

&lt;p&gt;부트스트래핑 과정은 Go의 런타임이 어떻게 작동하는지를 이해하는데 열쇠와 같은 구실을 한다. Go와 함께 앞으로 나아가고자 한다면 반드시 배워야한다. 그래서 Golang의 내부 시리즈의 다섯번째는 Go의 런타임, 특히 Go의 부트스트래핑 과정에 바치겠다. 이번에 독자가 배울 항목들은:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Go 부트스트래핑&lt;/li&gt;
&lt;li&gt;가변 스택 구현&lt;/li&gt;
&lt;li&gt;TLS 내부 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 포스트에 어셈블러 코드가 많이 포함되어 있는 점을 주목하라. 진행하기 위해 적어도 어셈블러의 기본 지식은 필요할 것이다. (속성 &lt;a href=&#34;https://golang.org/doc/asm&#34;&gt;Go 어셈블러 가이드&lt;/a&gt;가 여기 있다.) 이제 시작해 보자!&lt;/p&gt;

&lt;h1 id=&#34;프로그램-시작점-찾기&#34;&gt;프로그램 시작점 찾기&lt;/h1&gt;

&lt;p&gt;우선, Go 프로그램이 시작된 후 즉시 실행되는 함수가 무엇인지 찾아보자. 그러기 위해, 간단한 Go 앱을 제작할 것이다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;1 package main
2
3 func main() {
4     print(123)
5 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;그런 다음 컴파일하고 링크 할 필요가 있다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 go tool 6g test.go
2 go tool 6l test.6
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 과정을 통해 &lt;em&gt;6.out&lt;/em&gt; 이라고 불리는 실행 파일이 현재 디렉토리에 만들어 진다. 다음 단계는 &lt;a href=&#34;https://sourceware.org/binutils/docs/binutils/objdump.html&#34;&gt;objdump&lt;/a&gt; 툴을 사용한다. 이 툴은 리눅스에만 해당되는 툴이어서 윈도우나 맥 사용자들은 유사한 툴을 찾던지 이 단계를 그냥 건너 뛰어야 한다. 이제 다음 명령을 실행하라:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 objdump -f 6.out
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이것을 통해 시작 주소를 담고 있는 출력을 얻을 것이다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 6.out:     file format elf64-x86-64
2 architecture: i386:x86-64, flags 0x00000112:
3 EXEC_P, HAS_SYMS, D_PAGED
4 start address 0x000000000042f160
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;다음은, 실행파일을 역어셈블하고 이 주소에 위치한 함수가 무엇인지 알아 낸다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 objdump -d 6.out &amp;gt; disassemble.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;그런 다음 &lt;em&gt;disassemble.txt&lt;/em&gt; 파일을 열어서 “&lt;em&gt;42f160&lt;/em&gt;.”를 검색하여 다음과 같은 결과를 얻는다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 000000000042f160 &amp;lt;_rt0_amd64_linux&amp;gt;:
2   42f160:   48 8d 74 24 08              lea    0x8(%rsp),%rsi
3   42f165:   48 8b 3c 24                 mov    (%rsp),%rdi
4   42f169:   48 8d 05 10 00 00 00    lea    0x10(%rip),%rax        # 42f180 &amp;lt;main&amp;gt;
5   42f170:   ff e0                           jmpq   *%rax
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;좋아! 찾았다! 저자의 OS와 아키텍쳐에 해당하는 시작점은 &lt;em&gt;_rt0_amd64_linux&lt;/em&gt; 라는 함수이다.&lt;/p&gt;

&lt;h1 id=&#34;시작하는-순서&#34;&gt;시작하는 순서&lt;/h1&gt;

&lt;p&gt;이제 이 함수를 Go 런타임 소스코드에서 찾을 필요가 있다. 위치한 곳은 &lt;a href=&#34;https://github.com/golang/go/blob/master/src/runtime/rt0_linux_amd64.s&#34;&gt;rt0_linux_amd64.s&lt;/a&gt; 파일이다. Go runtime 패키지속을 들여다 보면, 많은 파일의 이름들이 OS와 아키텍쳐 이름에 연관된 어미들(postfixes)로 되어 있음을 발견할 수 있다. runtime 패키지가 빌드될 때, 현재 OS와 아키텍쳐에 상응하는 파일들만 선택되고 나머지는 건너뛴다. &lt;a href=&#34;https://github.com/golang/go/blob/master/src/runtime/rt0_linux_amd64.s&#34;&gt;rt0_linux_amd64.s&lt;/a&gt;를 더 자세히 들여다 보자:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8
2     LEAQ    8(SP), SI // argv
3     MOVQ    0(SP), DI // argc
4     MOVQ    $main(SB), AX
5     JMP AX
6
7 TEXT main(SB),NOSPLIT,$-8
8     MOVQ    $runtime·rt0_go(SB), AX
9     JMP AX
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;_rt0_amd64_linux&lt;/em&gt; 함수는 매우 단순하다. main 함수를 부르고 인수값 (&lt;em&gt;argc&lt;/em&gt; and &lt;em&gt;argv&lt;/em&gt;) 을 레지스터 (&lt;em&gt;DI&lt;/em&gt; and &lt;em&gt;SI&lt;/em&gt;)에 저장한다. 인수들은 스택에 위치하고 &lt;em&gt;SP&lt;/em&gt; (스택 포인터) 레지스터를 통해 접근할 수 있다. main 함수 역시 매우 간단하다. &lt;em&gt;runtime.rt0_go&lt;/em&gt; 를 호출한다. &lt;em&gt;runtime.rt0_go&lt;/em&gt; 함수는 좀 길고 더 복잡하다. 그래서 작은 부분들로 분해한 다음 하나씩 따로 설명할 것이다.&lt;/p&gt;

&lt;p&gt;첫번째 섹션은 이러하다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 MOVQ    DI, AX      // argc
2 MOVQ    SI, BX      // argv
3 SUBQ    $(4*8+7), SP        // 2args 2auto
4 ANDQ    $~15, SP
5 MOVQ    AX, 16(SP)
6 MOVQ    BX, 24(SP)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이전에 저장해 두었던 코맨드라인 인수값을 &lt;em&gt;AX&lt;/em&gt; 와 &lt;em&gt;BX&lt;/em&gt; 에 두고 스택 포인터를 감소시킨다. 두개의 4 바이트 변수를 위한 공간을 추가하고 16 비트로 정렬되게 조정한다. 마지막으로 인수값은 다시 스택에 이동시킨다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 // create istack out of the given (operating system) stack.
2 // _cgo_init may update stackguard.
3 MOVQ    $runtime·g0(SB), DI
4 LEAQ    (-64*1024+104)(SP), BX
5 MOVQ    BX, g_stackguard0(DI)
6 MOVQ    BX, g_stackguard1(DI)
7 MOVQ    BX, (g_stack+stack_lo)(DI)
8 MOVQ    SP, (g_stack+stack_hi)(DI)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;두번째 부분은 좀 더 까다롭다. 우선, 전역 변수 &lt;em&gt;runtime.g0&lt;/em&gt; 의 주소를 DI 레지스터에 올린다. 이 변수는 &lt;a href=&#34;https://github.com/golang/go/blob/master/src/runtime/proc1.go&#34;&gt;proc1.go&lt;/a&gt; 파일에 정의되어 있고 &lt;em&gt;runtime,g&lt;/em&gt; 타입에 속한다. 이 타입의 변수들은 시스템내 각 고루틴(goroutine)마다 만들어 진다. 독자가 추측할 수도 있듯이, &lt;em&gt;runtime.g0&lt;/em&gt; 는 루트 고루틴(root goroutine)을 나타낸다. 그런 다음 이 루트 고루틴의 스택을 묘사하는 필드들을 초기화한다. &lt;em&gt;stack.lo&lt;/em&gt; 와 &lt;em&gt;stack.hi&lt;/em&gt; 가 뜻하는 바는 분명하다. 이것들은 현재 고루틴의 시작과 끝을 가리키는 포인터 들이다. 그런데 &lt;em&gt;stackguard0&lt;/em&gt; 와 &lt;em&gt;stackguard1&lt;/em&gt; 필드는 무엇일까? 이 것들을 이해하기 위해서는 &lt;em&gt;runtime.rt0_go&lt;/em&gt; 함수를 분석하는 일을 잠시 접어 두고 Go 언어에서 스택 크기 변화에 대해 좀 더 자세히 알아 보아야 한다.&lt;/p&gt;

&lt;h1 id=&#34;go-언어에서-크기를-조정할-수-있는-스택의-구현&#34;&gt;Go 언어에서 크기를 조정할 수 있는 스택의 구현&lt;/h1&gt;

&lt;p&gt;Go 언어는 크기를 조정할 수 있는 스택을 사용한다. 각 고루틴은 작은 스택으로 시작해서 한계치에 도달하면 크기를 바꾼다. 물론 이 한계치에 도달했는지를 알아보는 방법이 있다. 사실 각 함수는 시작할 때 스택이 한계에 도달했는지를 확인한다. 이것이 어떻게 작동하는지 알아보기 위해 샘플 프로그램을 &lt;em&gt;-S&lt;/em&gt; 플래그를 이용해 다시 한번 컴파일 하자. 어셈블리 코드을 보게 될 것 이다. main 함수의 시작부분은 다음과 같다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 &amp;quot;&amp;quot;.main t=1 size=48 value=0 args=0x0 locals=0x8
2     0x0000 00000 (test.go:3)    TEXT    &amp;quot;&amp;quot;.main+0(SB),$8-0
3     0x0000 00000 (test.go:3)    MOVQ    (TLS),CX
4     0x0009 00009 (test.go:3)    CMPQ    SP,16(CX)
5     0x000d 00013 (test.go:3)    JHI ,22
6     0x000f 00015 (test.go:3)    CALL    ,runtime.morestack_noctxt(SB)
7     0x0014 00020 (test.go:3)    JMP ,0
8     0x0016 00022 (test.go:3)    SUBQ    $8,SP
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;우선 쓰레드 로컬 스토리지 (TLS)에서 한 값을 CX 레지스터에 올린다(TLS가 무엇인지는 &lt;a href=&#34;https://golangkorea.github.io/post/golang-internals/part3/&#34;&gt;이전 포스트&lt;/a&gt;에서 이미 설명한 바 있다). 이 값은 항상 현재 고루틴에 상응하는  &lt;em&gt;runtime.g&lt;/em&gt; 구조에 대한 포인터를 담고 있다. 그런 다음 스택포인터를 &lt;em&gt;runtime.g&lt;/em&gt; 구조내 16 바이트의 오프셋에 위치한 값과 비교한다. 계산해 보면 이 값이 &lt;em&gt;stackguard0&lt;/em&gt; 필드에 상응한다는 것을 쉽게 알 수 있다.&lt;/p&gt;

&lt;p&gt;바로 이것이 스택 한계치에 도달했는지를 확인하는 방식이다. 아직 도달하지 않았다면, 확인은 실패로 간주되어서 스택에 충분한 메모리가 할당될 때 까지 &lt;em&gt;runtime.morestack_noctxt&lt;/em&gt; 함수를 반복적으로 호출한다. &lt;em&gt;stackguard1&lt;/em&gt; 필드는 &lt;em&gt;stackguard0&lt;/em&gt; 와 매우 유사하게 작동한다. 하지만 Go 대신 C 스택 성장 프롤로그 (C stack growth prologue)내에서 사용된다. &lt;em&gt;runtime.morestack_noctxt&lt;/em&gt; 의 내부 작동 원리 또한 매우 흥미로운 주제이긴 하지만 나중에 논하기로 하겠다. 지금은 부트스트랩 과정으로 다시 돌아가기로 하자.&lt;/p&gt;

&lt;h1 id=&#34;계속되는-go-부트스트래핑에-대한-조사&#34;&gt;계속되는 Go 부트스트래핑에 대한 조사&lt;/h1&gt;

&lt;p&gt;시작하는 순서에 대해 더 나아가기 위해서 &lt;em&gt;runtime.rt0_go&lt;/em&gt; 함수내 다음 부분에 있는 코드를 살펴보기로 하자:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;01     // find out information about the processor we&#39;re on
02     MOVQ    $0, AX
03     CPUID
04     CMPQ    AX, $0
05     JE  nocpuinfo
06
07     // Figure out how to serialize RDTSC.
08     // On Intel processors LFENCE is enough. AMD requires MFENCE.
09     // Don&#39;t know about the rest, so let&#39;s do MFENCE.
10     CMPL    BX, $0x756E6547  // &amp;quot;Genu&amp;quot;
11     JNE notintel
12     CMPL    DX, $0x49656E69  // &amp;quot;ineI&amp;quot;
13     JNE notintel
14     CMPL    CX, $0x6C65746E  // &amp;quot;ntel&amp;quot;
15     JNE notintel
16     MOVB    $1, runtime·lfenceBeforeRdtsc(SB)
17 notintel:
18
19     MOVQ    $1, AX
20     CPUID
21     MOVL    CX, runtime·cpuid_ecx(SB)
22     MOVL    DX, runtime·cpuid_edx(SB)
23 nocpuinfo:
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 부분은 Go의 주요한 컨셉트들을 이해하는데 반드시 알아야 할 필요는 없다. 그래서 짧게 보고 넘어 가겠다. 여기에서는 지금 사용되고 있는 프로세서가 무엇인지 알아내려는 시도가 있다. 만약 인텔이면 &lt;em&gt;runtime·lfenceBeforeRdtsc&lt;/em&gt; 변수에 값을 매긴다. &lt;em&gt;runtime·cputicks&lt;/em&gt; 메서드에만 사용된 변수이다. 이 메서드는 &lt;em&gt;runtime·lfenceBeforeRdtsc&lt;/em&gt; 값에 의존하여 cpu 마다 다른 어셈블러 명령을 통해 tick을 알아낸다. 마지막으로 CPUID 어셈블러 명령을 호출하고, 실행하고, 결과를 &lt;em&gt;runtime·cpuid_ecx&lt;/em&gt; 와 &lt;em&gt;runtime·cpuid_edx&lt;/em&gt; 변수에 저장한다. 이 변수들은 &lt;a href=&#34;https://github.com/golang/go/blob/master/src/runtime/alg.go&#34;&gt;alg.go&lt;/a&gt; 파일에서 컴퓨터의 아키텍쳐에 따라 기본적으로 지원되는 적합한 헤쉬잉 알고리즘을 선택하는데 사용된다.&lt;/p&gt;

&lt;p&gt;자, 다음 코드로 이동하자.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;01 // if there is an _cgo_init, call it.
02 MOVQ    _cgo_init(SB), AX
03 TESTQ   AX, AX
04 JZ  needtls
05 // g0 already in DI
06 MOVQ    DI, CX  // Win64 uses CX for first parameter
07 MOVQ    $setg_gcc&amp;lt;&amp;gt;(SB), SI
08 CALL    AX
09
10 // update stackguard after _cgo_init
11 MOVQ    $runtime·g0(SB), CX
12 MOVQ    (g_stack+stack_lo)(CX), AX
13 ADDQ    $const__StackGuard, AX
14 MOVQ    AX, g_stackguard0(CX)
15 MOVQ    AX, g_stackguard1(CX)
16
17 CMPL    runtime·iswindows(SB), $0
18 JEQ ok
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 코드 조각은 &lt;em&gt;cgo&lt;/em&gt; 가 활성화되어 있을 때 만 실행된다. &lt;em&gt;cgo&lt;/em&gt; 는 따로 다루어야 할 주제이고 앞으로 나올 포스트에서 다룰지도 모르겠다. 지금 이 시점에서는 기본적인 부트스트랩 작업의 흐름만을 이해하고 자 하기 때문에, 건너 뛸 것이다.&lt;/p&gt;

&lt;p&gt;다음 코드 조각은 TLS를 설정하는 장본인이다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;01 needtls:
02     // skip TLS setup on Plan 9
03     CMPL    runtime·isplan9(SB), $1
04     JEQ ok
05     // skip TLS setup on Solaris
06     CMPL    runtime·issolaris(SB), $1
07     JEQ ok
08
09     LEAQ    runtime·tls0(SB), DI
10     CALL    runtime·settls(SB)
11
12     // store through it, to make sure it works
13     get_tls(BX)
14     MOVQ    $0x123, g(BX)
15     MOVQ    runtime·tls0(SB), AX
16     CMPQ    AX, $0x123
17     JEQ 2(PC)
18     MOVL    AX, 0   // abort
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;TLS에 대해서는 이미 언급한 바 있고, 이제는 어떻게 구현되었는지를 알아보자.&lt;/p&gt;

&lt;h1 id=&#34;tls-내부-구현&#34;&gt;TLS 내부 구현&lt;/h1&gt;

&lt;p&gt;이전 코드 조각을 자세히 들여다 보면, 실제로 작업을 하는 부분은 한 줄에 불과하다는 것을 쉽게 이해할 수 있다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 LEAQ    runtime·tls0(SB), DI
2     CALL    runtime·settls(SB)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;다른 부분들은 TLS가 os에서 지원되지 않을 때 건너 뛰거나 TLS가 정확하게 작동하는지 확인하는데 사용된다. 위의 두 줄은 &lt;em&gt;runtime.tls0&lt;/em&gt; 변수의 주소를 DI 레지스터에 저장하고 &lt;em&gt;runtime.settls&lt;/em&gt; 함수를 호출한다. 아래에서 이 함수의 코드를 살펴 보자:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;01 // set tls base to DI
02 TEXT runtime·settls(SB),NOSPLIT,$32
03     ADDQ    $8, DI  // ELF wants to use -8(FS)
04
05     MOVQ    DI, SI
06     MOVQ    $0x1002, DI // ARCH_SET_FS
07     MOVQ    $158, AX    // arch_prctl
08     SYSCALL
09     CMPQ    AX, $0xfffffffffffff001
10     JLS 2(PC)
11     MOVL    $0xf1, 0xf1  // crash
12     RET
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;코멘트를 보면 이 함수가 &lt;em&gt;arch_prctl&lt;/em&gt; 시스템 호출을 하며 &lt;em&gt;ARCH_SET_FS&lt;/em&gt; 를 인수로 전달한다는 것을 알 수 있다. 또 이 시스템 호출이 &lt;em&gt;FS&lt;/em&gt; 세그먼트 레지스터의 시작점(base)을 정하는 것을 볼 수 있다. 위의 경우, TLS는 &lt;em&gt;runtime.tls0&lt;/em&gt; 변수를 가리킨다.&lt;/p&gt;

&lt;p&gt;main 함수의 어셈블러 코드의 시작부분에서 본 명령을 기억하는가?&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 0x0000 00000 (test.go:3)    MOVQ    (TLS),CX
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이전에 설명한 바 있듯이 이 명령은 &lt;em&gt;runtime.g&lt;/em&gt; 구조체 인스턴스의 주소를 CX 레지스터에 올린다. 이 구조체는 현재 고루틴에 대한 서술이고 쓰레드 로컬 스토리지 (thread local storage)에 저장된다. 이제 이 명령이 어떻게 기계어로 번역되는지 밝혀내고 이해할 수 있다. 이전에 만든 &lt;em&gt;disassembly.txt&lt;/em&gt; 파일을 열고 &lt;em&gt;main.main&lt;/em&gt; 함수를 찾아보면, 첫번째 명령은 다음과 같이 생겼다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 400c00:       64 48 8b 0c 25 f0 ff    mov    %fs:0xfffffffffffffff0,%rcx
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;(&lt;em&gt;%fs:0xfffffffffffffff0&lt;/em&gt;) 명령의 콜론이 의미하는 바는 세그멘테이션의 주소화이다 (자세한 내용은 &lt;a href=&#34;http://thestarman.pcministry.com/asm/debug/Segments.html&#34;&gt;여기&lt;/a&gt;를 참조하라).&lt;/p&gt;

&lt;h1 id=&#34;시작하는-순서로-다시-돌아가서&#34;&gt;시작하는 순서로 다시 돌아가서&lt;/h1&gt;

&lt;p&gt;마지막으로 &lt;em&gt;runtime.rt0_go&lt;/em&gt; 함수의 마지막 두 부분을 살펴보자:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;01 ok:
02     // set the per-goroutine and per-mach &amp;quot;registers&amp;quot;
03     get_tls(BX)
04     LEAQ    runtime·g0(SB), CX
05     MOVQ    CX, g(BX)
06     LEAQ    runtime·m0(SB), AX
07
08     // save m-&amp;gt;g0 = g0
09     MOVQ    CX, m_g0(AX)
10     // save m0 to g0-&amp;gt;m
11     MOVQ    AX, g_m(CX)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;TLS 주소를 BX 레지스터에 올리고 &lt;em&gt;runtime·g0&lt;/em&gt; 변수의 주소를 TLS에 저장한다. &lt;em&gt;runtime.m0&lt;/em&gt; 변수를 초기화한다. 만약 &lt;em&gt;runtime.g0&lt;/em&gt; 가 루트 고루틴을 뜻하면 &lt;em&gt;runtime.m0&lt;/em&gt; 는 이 고루틴을 실행하는 루트 오퍼레이팅 시스템 쓰레드에 상응한다. &lt;em&gt;runtime.g0&lt;/em&gt; 와 &lt;em&gt;runtime.m0&lt;/em&gt; 구조를 앞으로 나올 포스트에서 자세히 살펴볼지도 모르겠다.&lt;/p&gt;

&lt;p&gt;시작하는 순서의 마지막 부분은 인수를 초기화하고 여러 함수를 호출하는 것이다. 하지만 이 주제는 따로 다루어야 할 토론거리이다.&lt;/p&gt;

&lt;h1 id=&#34;golang-에-대한-더-알아보기&#34;&gt;Golang 에 대한 더 알아보기&lt;/h1&gt;

&lt;p&gt;이제 부트스트랩 과정의 내부 메커니즘에 대해 배웠고 어떻게 스택이 구현되었는지 알아 보았다. 계속 나아가기 위해서는 시작하는 순서의 마지막 부분에 대한 분석이 필요하다. 이것이 저자의 다음 포스트의 주제가 될 것이다. 언제 나올지 연락받고 싶은 독자는 밑의 subscribe 버튼을 누르던지 &lt;a href=&#34;http://www.twitter.com/altoros&#34;&gt;@altoros&lt;/a&gt;를 팔로우하기 바란다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;원문: &lt;a href=&#34;http://blog.altoros.com/golang-internals-part-5-runtime-bootstrap-process.html&#34;&gt;Golang Internals, Part 5: the Runtime Bootstrap Process&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;저자: Siarhei Matsiukevich&lt;/li&gt;
&lt;li&gt;번역자: Jhonghee Park&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golang의 내부, 4부: 오브젝트 파일, 그리고 함수 메타데이터</title>
      <link>https://golangkorea.github.io/post/golang-internals/part4/</link>
      <pubDate>Sun, 18 Sep 2016 16:20:29 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/golang-internals/part4/</guid>
      <description>

&lt;p&gt;오늘은, Func 구조에 대해 좀 더 자세히 들여다 보고 어떻게 가비지 컬렉션이 작동하는지 몇가지 자세한 내용을 논하겠다.&lt;/p&gt;

&lt;p&gt;이 포스트는 &lt;a href=&#34;https://golangkorea.github.io/post/golang-internals/part3/&#34;&gt;Golang의 내부, 3부: 링커, 오브젝트 파일, 그리고 재배치&lt;/a&gt;의 연속이어서, 독자가 아직 읽지 않았다면 이 포스트를 소화하기 전에 읽기를 적극 권장한다.&lt;/p&gt;

&lt;h1 id=&#34;함수-메타데이터의-구조&#34;&gt;함수 메타데이터의 구조&lt;/h1&gt;

&lt;p&gt;재배치에 대한 주요한 아이디어는 3부를 통해 분명해 졌을 것이다. 이제 main 메서드의 Func 구조를 살펴보자:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;01 Func: &amp;amp;goobj.Func{
02     Args:    0,
03     Frame:   8,
04     Leaf:    false,
05     NoSplit: false,
06     Var:     {
07     },
08     PCSP:   goobj.Data{Offset:255, Size:7},
09     PCFile: goobj.Data{Offset:263, Size:3},
10     PCLine: goobj.Data{Offset:267, Size:7},
11     PCData: {
12         {Offset:276, Size:5},
13     },
14     FuncData: {
15         {
16             Sym:    goobj.SymID{Name:&amp;quot;gclocals·3280bececceccd33cb74587feedb1f9f&amp;quot;, Version:0},
17          Offset: 0,
18     },
19     {
20          Sym:    goobj.SymID{Name:&amp;quot;gclocals·3280bececceccd33cb74587feedb1f9f&amp;quot;, Version:0},
21                Offset: 0,
22            },
23        },
24        File: {&amp;quot;/home/adminone/temp/test.go&amp;quot;},
25    },
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 구조체는 Go언어의 런타임이 사용하는, 컴파일러가 오브젝트 파일에 방출한 함수 메타데이터로 생각해 볼 수 있다. &lt;a href=&#34;https://docs.google.com/document/d/1lyPIbmsYbXnpNj57a261hgOYVpNRcgydurVQIyZOz_o/pub&#34;&gt;이 문서&lt;/a&gt;를 통해 Func내 정확한 포맷과 여러 필드들의 의미에 대한 설명을 접할 수 있다. 이제, 런타임에서 이 메타데이터가 어떻게 사용되는지 보겠다.&lt;/p&gt;

&lt;p&gt;runtime 패키지 안에서 이 메타데이터는 다음 구조체에 매핑되어 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;01 type _func struct {
02     entry   uintptr // start pc
03     nameoff int32   // function name
04
05     args  int32 // in/out args size
06     frame int32 // legacy frame size; use pcsp if possible
07
08     pcsp      int32
09     pcfile    int32
10     pcln      int32
11     npcdata   int32
12     nfuncdata int32
13 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;오브젝트 파일 안에 있는 정보가 모두 다 직접적으로 매핑되어 있는 것은 아니다. 몇몇 필드들은 링커에만 사용된다. 그렇다 해도 여기에서 가장 흥미로운 필드들은 &lt;em&gt;pcsp&lt;/em&gt;, &lt;em&gt;pcfile&lt;/em&gt;, 그리고 &lt;em&gt;pcln&lt;/em&gt; 이다. 이 필드들은 &lt;a href=&#34;http://en.wikipedia.org/wiki/Program_counter&#34;&gt;프로그램 카운터&lt;/a&gt;가 stack pointer, filename, 그리고 line으로 번역될 때 사용된다.&lt;/p&gt;

&lt;p&gt;예를 들면, &lt;em&gt;panic&lt;/em&gt; 이 발생할 경우 이 메타데이터 필드들이 필요할 것이다. 그 순간에 런타임이 알고 있는 바는 오직 &lt;em&gt;panic&lt;/em&gt; 을 야기한 현재의 어셈블리 명령의 프로그램 카운터이다. 그래서 런타임은 그 카운터를 이용해 현재 파일과 라인 번호, 그리고 stack trace 전부를 얻는 것이다. 파일과 라인 번호는 &lt;em&gt;pcfile&lt;/em&gt; 과 &lt;em&gt;pcln&lt;/em&gt; 필드를 이용하면 바로 해결된다. stack trace는 &lt;em&gt;pcsp&lt;/em&gt; 를 이용하여 재귀적으로 해결한다.&lt;/p&gt;

&lt;p&gt;이제 프로그램 카운터를 가지고 어떻게 상응하는 라인 번호를 얻을 수 있는지에 대한 질문에 답을 하자. 답을 얻기 위해서는 어셈블리 코드를 들여다 보고 오브젝트 파일에 라인 번호가 어떻게 저장되어 있는 지를 이해해야 한다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 0x001a 00026 (test.go:4)    MOVQ    $1,(SP)
2     0x0022 00034 (test.go:4)    PCDATA  $0,$0
3     0x0022 00034 (test.go:4)    CALL    ,runtime.printint(SB)
4     0x0027 00039 (test.go:5)    ADDQ    $8,SP
5     0x002b 00043 (test.go:5)    RET ,
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로그램 카운터 26에서 38까지는 라인 번호 4에 상응하고 카운터 39에서 &lt;em&gt;next_function_program_counter - 1&lt;/em&gt; 까지는 라인 번호 5에 해당된다. 효율적 공간사용을 생각하면 다음과 같은 맵을 저장하는 것으로 충분하다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 26 - 4
2 39 - 5
3 …
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이것은 컴파일러가 하는 일과 거의 일치한다. &lt;em&gt;pcln&lt;/em&gt; 필드는 현재 실행중인 함수의 첫번째 프로그램 카운터에 상응하는 특정한 오프셋을 맵안에서 가리키고 있다. 이 오프셋과 또 다음 함수의 첫번째 프로그램 카운터의 오프셋을 알고, 런타임은 바이너리 검색을 이용해 주어진 프로그램 카운터에 상응하는 라인 번호를 찾는다.&lt;/p&gt;

&lt;p&gt;Go 언어에서 이런 아이디어는 일반화 되어 있다. 라인 번호와 스택 포인터만 프로그램 카운터에 맵팅되어 있는게 아니라 어떤 정수 값도 매핑될 수 있다. &lt;em&gt;PCDATA&lt;/em&gt; 명령을 통해서 가능한 것이다. 매번 링커는 다음 명령을 찾는다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 0x0022 00034 (test.go:4)    PCDATA  $0,$0
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 명령은 실제로 어셈블러 명령을 생산하지 않는다. 대신, 이 명령의 두번째 인수를 맵안에서 현재의 프로그램 카운터를 사용해 저장하고, 첫번째 인수는 어떤 맵이 사용되는 지를 나타낸다. 이 첫번째 인수를 통해, 새로운 맵을 쉽게 첨가할 수 있는데, 컴파일러와 런타임에는 그 의미가 알려지지만 링커에게는 보이지 않는다.&lt;/p&gt;

&lt;h1 id=&#34;가비지-컬렉터는-어떻게-함수-메타데이터를-사용하는가&#34;&gt;가비지 컬렉터는 어떻게 함수 메타데이터를 사용하는가&lt;/h1&gt;

&lt;p&gt;마지막으로 아직 설명을 더 명확하게 해야할 함수 메타데이터의 내용은 FuncData 배열인데, 가비지 컬렉션에 필요한 정보를 담고 있다. Go 언어는 &lt;a href=&#34;http://www.brpreiss.com/books/opus5/html/page424.html&#34;&gt;mark-and-sweep&lt;/a&gt; 가비지 컬렉터 (GC)를 사용하는데 두 단계를 거쳐 동작한다. 첫번째 단계인 (mark)에서는, 모든 객체를 섭렵하면서 아직 사용중인 것들은 &amp;ldquo;reachable&amp;rdquo;로 표시한다. 표시되지 않은 모든 객체는 두번째 단계인 (sweep)에서 제거된다.&lt;/p&gt;

&lt;p&gt;그래서, 가비지 컬렉터는 전역 변수, 프로세서 레지스터, 스택 프레임, 그리고 이미 위치가 알려진 객체내 포인터들과 같이 잘 알려진 위치들내 도달할 수 있는(reachable) 객체를 찾아보면서 시작한다. 하지만 곰곰히 생각해 보면, 스택 프레임안에서 포인터를 찾아내는 것이 그렇게 쉽지는 않는 일이다. 그렇다면 런타임이 가비지 컬렉션을 실행할때 스택안에서 어떻게 포인터와 포인터가 아닌 타입의 변수들을 알아 내는 것일까? 바로 여기에서 &lt;em&gt;FuncData&lt;/em&gt; 가 등장하는 것이다.&lt;/p&gt;

&lt;p&gt;각 함수마다 컴파일러는 두개의 변수를 만든다. 하나는 스택 프레임의 인수들을 위한 비트맵 벡터를 담고 있다. 다른 하나는 나머지 프레임을 위한 비트맵으로 함수에 정의된 포인터 타입의 모든 지역 변수들을 포함한다. 이 변수들은 각자 가비지 컬렉터에게 스택 프레임안에 포인터들이 어디에 위치하는지 정확하게 알려주고 이는 가비지 컬렉터가 일을 하는 데 충분한 정보이다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;PCDATA&lt;/em&gt; 와 같이 &lt;em&gt;FUNCDATA&lt;/em&gt; 역시 의사-Go 어셈블리 명령(pseudo-Go assembly instruction)에 의해 발생된 것임을 언급할 가치가 있겠다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;1 0x001a 00026 (test.go:3)    FUNCDATA    $0,gclocals·3280bececceccd33cb74587feedb1f9f+0(SB)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 명령의 첫번째 인수는 이것이 인수들을 위한 함수 데이터인지 아니면 지역 변수 공간인지를 나타낸다. 두번째 인수는 실제로 GC 마스크를 담고 있는 숨겨진 변수에 대한 참조 값이다.&lt;/p&gt;

&lt;h1 id=&#34;golang에-대해-더-알아보기&#34;&gt;Golang에 대해 더 알아보기&lt;/h1&gt;

&lt;p&gt;앞으로 나올 포스트에서는 Go 언어의 부트 스트랩 과정을 얘기하겠다. 런타임이 어떻게 작동하는지를 이해하는데 중요한 단서이다. 일주일 뒤에 보자.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;원문: &lt;a href=&#34;http://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html&#34;&gt;Golang Internals, Part 4: Object Files and Function Metadata&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;저자: Siarhei Matsiukevich&lt;/li&gt;
&lt;li&gt;번역자: Jhonghee Park&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golang의 내부, 3부: 링커, 오브젝트 파일, 그리고 재배치</title>
      <link>https://golangkorea.github.io/post/golang-internals/part3/</link>
      <pubDate>Sat, 17 Sep 2016 16:20:29 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/golang-internals/part3/</guid>
      <description>

&lt;p&gt;오늘은 Go 링커와 오브젝트 파일, 그리고 재배치(relocations)에 대해 얘기해 보자.&lt;/p&gt;

&lt;p&gt;이런 것들이 독자들과 무슨 상관이 있을까? 만약 독자가 어떤 대형 프로젝트의 내부에 대해 배우고자 한다면, 첫번째 할 일이 그 것을 콤포넌트나 모듈로 자를 필요가 있다. 둘째로 이 모듈들이 서로에게 어떤 인터페이스를 제공하는지 이해할 필요가 있다. Go 언어 프로젝트의 경우, 이런 상위 모듈들이 컴파일러, 링커, 그리고 런타임이다. 컴파일러가 제공하고 링커가 사용하는 것이 오프젝트 파일인데, 오늘은 그 것으로 조사를 시작해 보자.&lt;/p&gt;

&lt;h1 id=&#34;go-오브젝트-파일-생성하기&#34;&gt;Go 오브젝트 파일 생성하기&lt;/h1&gt;

&lt;p&gt;실용적인 실험을 하나 해 보자-아주 간단한 프로그램을 하나 만들고, 컴파일하고, 어떤 오브젝트 파일이 만들어 지는지 관찰하자. 저자의 경우, 프로그램은 다음과 같다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;1: package main
2:
3: func main() {
4:  print(1)
5: }
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;너무 쉽지 않은가? 이제 컴파일을 한다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;go tool 6g test.go
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 명령은 &lt;em&gt;test.6&lt;/em&gt; 오브젝트 파일을 생산한다. 이 파일의 내부 구조를 조사하기 위해, &lt;a href=&#34;https://github.com/golang/go/tree/master/src/cmd/internal/goobj&#34;&gt;goobj&lt;/a&gt; 라이브러리를 사용하겠다. 이 라이브러리는 내부적으로 Go 소스 코드에 채택되어 주로 유닛 테스트를 구현하는데 쓰인다. 이 유닛 테스트는 여러 상황에서 오브젝트 파일이 정확히 생성되었는지를 테스트한다. 이 블로그 포스트를 위해 &lt;em&gt;goobj&lt;/em&gt; 라이브러리를 통해 생성된 출력을 콘솔로 프린트하는 매우 간단한 프로그램을 만들었다. 이 프로그램의 소스코드는 &lt;a href=&#34;https://github.com/s-matyukevich/goobj_explorer&#34;&gt;여기&lt;/a&gt;에서 살펴볼 수 있다.&lt;/p&gt;

&lt;p&gt;무엇보다도 우선, 저자의 프로그램을 다운받아 설치해야 한다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;go get github.com/s-matyukevich/goobj_explorer
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;그런 후에 다음의 명령을 실행하라:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;goobj_explorer -o test.6
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제 &lt;em&gt;goob.Package&lt;/em&gt; 구조를 콘솔안에서 살펴 볼 수 있을 것이다.&lt;/p&gt;

&lt;h1 id=&#34;오브젝트-파일-조사하기&#34;&gt;오브젝트 파일 조사하기&lt;/h1&gt;

&lt;p&gt;이 오브젝트 파일에서 가장 흥미로운 부분은 &lt;em&gt;Syms&lt;/em&gt; 배열이다. 이것은 실제로 심볼 테이블이다. 프로그램안에 정의된 모든 것들, 함수, 전역 변수, 타입, 상수, 등이 이 테이블에 적혀있다. &lt;em&gt;main&lt;/em&gt; 함수에 상응하는 엔트리에 대해 살펴보자. (Roloc 과 Func 필드는 출력에서 생략되었음을 주목하라. 이 필드들은 나중에 논하겠다.)&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&amp;amp;goobj.Sym{
            SymID: goobj.SymID{Name:&amp;quot;main.main&amp;quot;, Version:0},
            Kind:  1,
            DupOK: false,
            Size:  48,
            Type:  goobj.SymID{},
            Data:  goobj.Data{Offset:137, Size:44},
            Reloc: ...,
            Func:  ...,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;goobj.Sum&lt;/em&gt; 구조내 필드의 이름들은 따로 설명이 필요 없다:&lt;/p&gt;

&lt;style type=&#34;text/css&#34;&gt;&lt;!--
.myTable { background-color:white;border-collapse:collapse; } .myTable th { background-color:#E0E0E0;color:black; } .myTable td, .myTable th { padding:5px;border:1px solid #989898; }
--&gt;&lt;/style&gt;

&lt;table class=&#34;myTable&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;&lt;center&gt;필드&lt;/center&gt;&lt;/th&gt;
&lt;th style=&#34;width: 530px;&#34; width=&#34;70%&#34;&gt;&lt;center&gt;설명&lt;/center&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;SumID&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;독특한 심볼 아이디로 심볼의 이름과 버전으로 구성된다. 버전을 통해 동일한 이름에 차이를 부여한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Kind&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;어떤 종류의 심볼에 속하는지를 나타낸다 (상세한 내용은 나중에).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;DupOK&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;이 필드는 중복된 이름(같은 이름의 심볼들)이 허락되는지를 나타낸다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Size&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;심볼 데이터의 크기.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Type&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;만약 있는 경우, 심볼 타입을 대표하는 또 다른 심볼에 대한 레퍼런스.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Data&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;바이너리 데이터를 가진다. 다른 종류의 심볼에 따라 다른 의미를 갖고 있다. 예를 들어, 함수에는 어셈블리 코드를, 문자열 심볼에는 원자재 문자열 콘텐트, 기타 등등.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Reloc&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;재배치 리스트 (더 상세한 내용은 나중에 제공될 것이다.)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Func&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;함수 심볼에 대한 특별한 함수 메타 데이터를 갖고 있다. (자세한 내용은 아래를 보라).&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이제, 다른 종류의 심볼들을 살펴보자. 모든 사용 가능한 종류의 심볼들이 상수로서 &lt;em&gt;goobj&lt;/em&gt; 패키지 (&lt;a href=&#34;https://github.com/golang/go/blob/master/src/cmd/internal/goobj/read.go#L30&#34;&gt;여기&lt;/a&gt;)에서 찾아 볼수 있)안에 정의되어 있다. 아래에, 이러한 상수들의 첫번째 부분을 복사해 놓았다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;const (
	_ SymKind = iota

	// readonly, executable
	STEXT
	SELFRXSECT

	// readonly, non-executable
	STYPE
	SSTRING
	SGOSTRING
	SGOFUNC
	SRODATA
	SFUNCTAB
	STYPELINK
	SSYMTAB // TODO: move to unmapped section
	SPCLNTAB
	SELFROSECT
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;보다시피, main.main 심볼은 종류 1에 속하고 &lt;em&gt;STEXT&lt;/em&gt; 상수에 상응한다. &lt;em&gt;STEXT&lt;/em&gt; 는 실행 가능한 코드를 갖는 심볼이다. 이제, &lt;em&gt;Reloc&lt;/em&gt; 배열을 살펴보자. 다음과 같은 struct들로 구성되어 있다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Reloc struct {
    Offset int
    Size   int
    Sym    SymID
    Add    int
    Type int
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;각 재배치는 &lt;em&gt;[Offset, Offset+Size]&lt;/em&gt; 간격에 위치한 바이트들이 특정 주소로 교체되어야 함을 암시한다. 이 주소는 &lt;em&gt;Sym&lt;/em&gt; 심볼의 위치에 &lt;em&gt;Add&lt;/em&gt; 바이트 숫자를 더하여 계산된다.&lt;/p&gt;

&lt;h1 id=&#34;재배치-이해하기&#34;&gt;재배치 이해하기&lt;/h1&gt;

&lt;p&gt;이제 예를 통해 재배치가 어떻게 작동하는지를 알아보자. 그러기 위해서, &lt;em&gt;-S&lt;/em&gt; 스위치를 이용해 프로그램을 컴파일 할 필요가 있다. &lt;em&gt;-s&lt;/em&gt; 스위치는 생성된 어셈블리 코드를 출력할 것이다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;go tool 6g -S test.go
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;어셈블러를 들여다 보면서 main 함수를 찾아보자.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;quot;.main t=1 size=48 value=0 args=0x0 locals=0x8
    0x0000 00000 (test.go:3)    TEXT    &amp;quot;&amp;quot;.main+0(SB),$8-0
    0x0000 00000 (test.go:3)    MOVQ    (TLS),CX
    0x0009 00009 (test.go:3)    CMPQ    SP,16(CX)
    0x000d 00013 (test.go:3)    JHI ,22
    0x000f 00015 (test.go:3)    CALL    ,runtime.morestack_noctxt(SB)
    0x0014 00020 (test.go:3)    JMP ,0
    0x0016 00022 (test.go:3)    SUBQ    $8,SP
    0x001a 00026 (test.go:3)    FUNCDATA    $0,gclocals·3280bececceccd33cb74587feedb1f9f+0(SB)
    0x001a 00026 (test.go:3)    FUNCDATA    $1,gclocals·3280bececceccd33cb74587feedb1f9f+0(SB)
    0x001a 00026 (test.go:4)    MOVQ    $1,(SP)
    0x0022 00034 (test.go:4)    PCDATA  $0,$0
    0x0022 00034 (test.go:4)    CALL    ,runtime.printint(SB)
    0x0027 00039 (test.go:5)    ADDQ    $8,SP
    0x002b 00043 (test.go:5)    RET ,
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;나중에 올 블로그 포스트에서 이 코드에 대해 더 자세히 살펴보며 Go의 런타임이 어떻게 작동하는지를 이해하기 위한 시도들 할 것이다. 지금은 다음 한줄에 관심이 있다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;0x0022 00034 (test.go:4)	CALL	,runtime.printint(SB)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 명령은 함수 데이터내 (16진수로는) 0x0022의 오프셋 이나 (10진수로는) 00034 오프셋에 위치한다. 이 줄은 실제로 &lt;em&gt;runtime.printint&lt;/em&gt; 함수를 호출하는 책임을 진다. 문제는 컴파일러가 컴파일이 진행되는 동안 &lt;em&gt;runtime.printint&lt;/em&gt; 함수의 정확한 주소를 모른다는 것이다. 이 함수는 컴파일러가 전혀 모르는 다른 오브젝트 파일내에 위치한다. 그런 경우, 컴파일러는 재배치를 사용한다. 아래는 이 메서드 호출에 상응하는 정확한 재배치이다. (저자가 &lt;em&gt;goobj_explorer&lt;/em&gt; 유틸리티의 첫번째 출력에서 복사해 왔다.):&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;{
    Offset: 35,
    Size:   4,
    Sym:    goobj.SymID{Name:&amp;quot;runtime.printint&amp;quot;, Version:0},
    Add:    0,
    Type:   3,
},
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 재배치는 링커에게 35 바이트의 오프셋에서 시작하면서, 4 바이트의 데이터를 &lt;em&gt;runtime.printint&lt;/em&gt; 심볼의 시작점 주소로 교체할 필요가 있다고 말한다. 하지만 메인 함수 데이터로 부터 35 바이트의 오프셋는 실제로 이전에 본적이 있는 호출 명령(call instruction)의 인수이다. (이 (호출) 명령은 34 바이트의 오프셋에서 시작한다. 1 바이트는 호출 명령 코드이고 4 바이트는 이 명령의 주소를 가리킨다.)&lt;/p&gt;

&lt;h1 id=&#34;링커는-어떻게-작동하는가&#34;&gt;링커는 어떻게 작동하는가&lt;/h1&gt;

&lt;p&gt;이제 위의 설명을 이해한다면, 링커가 어떻게 작동하는 지를 알아낼 수 있다. 다음의 개요는 매우 단순화 시킨 것이긴 하지만 주요한 아이디어를 반영한다:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;링커는 메인 패키지로 부터 참조된 모든 패키지의 심볼을 모아서 하나의 긴 바이트 배열(혹은 바이너리 이미지)에 실는다.&lt;/li&gt;
&lt;li&gt;각 심볼에 대해서는, 링커가 이러한 이미지내의 주소를 계산한다.&lt;/li&gt;
&lt;li&gt;그런다음, 모든 심볼에 대해 정의된 재배치를 적용한다. 링커가 그런 재배치에서 참조된 모든 다른 심볼들의 정확한 주소들들 알고 있기 때문에 매우 쉬운 일이다.&lt;/li&gt;
&lt;li&gt;링커는 (리눅스의) Executable and Linkable (ELF) 포맷이나 (윈도우의) Portable Executable (PE) 포맷에 필요한 모든 헤더를 준비한다. 그런 다음, 그 결과물로 링커는 실행파일을 발생시킨다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tls-이해하기&#34;&gt;TLS 이해하기&lt;/h1&gt;

&lt;p&gt;조심성 있는 독자는 main 메서드에 대해 &lt;em&gt;goobj_explorer&lt;/em&gt; 유틸리티 출력속에 이상한 재배치가 있음을 알아챌 것이다. 어떤 메서드 호출에도 상응하지 않고 심지어 빈 심볼을 가리키고 있다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;{
    Offset: 5,
    Size:   4,
    Sym:    goobj.SymID{},
    Add:    0,
    Type:   9,
},
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;과연, 이 재배치가 하는 것이 무엇일까? 5 바이트의 오프셋을 가지고 있고 크기가 4 바이트임을 알 수 있다. 이 오프셋에는 다음 명령이 있다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;0x0000 00000 (test.go:3)    MOVQ    (TLS),CX
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;0 오프셋에서 시작하고 9 바이트을 차지한다 (다음 명령이 9 바이트 오프셋애서 시작하는 걸로 알 수 있다). 추측컨대, 이 재배치는 낯선 &lt;em&gt;(TLS)&lt;/em&gt; 구문을 어떤 주소로 교체한다. 그러면 TLS는 무엇이며, 무슨 주소를 사용하는가?&lt;/p&gt;

&lt;p&gt;TLS는 쓰레드 지역 저장 공간(Thread Local Storage)의 축약형이다. 이 기술은 많은 프로그래밍 언어에 사용되었는데 상세한 내용은 &lt;a href=&#34;https://en.wikipedia.org/wiki/Thread-local_storage&#34;&gt;여기&lt;/a&gt;를 참조하라. 간단하게 설명하면, 다른 쓰레드에 의해 사용될 때, 다른 메모리 장소를 가리키는 변수의 사용을 가능하게 한다.&lt;/p&gt;

&lt;p&gt;Go 언어에서 TLS는 &lt;em&gt;G 구조체&lt;/em&gt; 를 가리키는 포인터를 저장하는 데 사용된다. &lt;em&gt;G 구조체&lt;/em&gt; 는 특정한 Go 루틴 내부의 상세한 내용을 담고 있는데 나중에 올 블로그 포스트에서 더 자세히 다룰 것이다. 그러므로, 다른 Go 루틴들이 어떤 한 Go 루틴을 접근할 때, 이 Go 루틴 내부의 자세한 정보를 담고 있는 구조체를 가리키는 변수가 항상 존재한다는 얘기다. 이 변수의 위치는 링커에게 알려져 있어서 (우리가) 분석중인 명령안에서 이 변수가 CX 레지스터에 이동된다는 것을 알 수 있다. TLS는 아키텍쳐마다 다르게 구현될 수 있다. AMD64에서는, &lt;em&gt;FS&lt;/em&gt; 레지스터를 통해 구현되어서, 이 명령은 &lt;em&gt;MOVQ FS, CX&lt;/em&gt; 로 번역될 수 있다.&lt;/p&gt;

&lt;p&gt;재배치에 대한 토론을 마감하기 위해, 모든 재배치 타입을 담고 있는 열거형 타입(enum) 을 소개하겠다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;// Reloc.type
enum
{
	R_ADDR = 1,
	R_SIZE,
	R_CALL, // relocation for direct PC-relative call
	R_CALLARM, // relocation for ARM direct call
	R_CALLIND, // marker for indirect call (no actual relocating necessary)
	R_CONST,
	R_PCREL,
	R_TLS,
	R_TLS_LE, // TLS local exec offset from TLS segment register
	R_TLS_IE, // TLS initial exec offset from TLS base pointer
	R_GOTOFF,
	R_PLT0,
	R_PLT1,
	R_PLT2,
	R_USEFIELD,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 enum에서 볼 수 있듯이, 재배치 타입 3는 R_CALL 이고 재배치 타입 9은 R_TLS이다. 이 enum 이름들은 방금 설명한 행동들을 완벽하게 설명한다.&lt;/p&gt;

&lt;h1 id=&#34;go-오브젝트-파일에-대한-부연-설명&#34;&gt;Go 오브젝트 파일에 대한 부연 설명&lt;/h1&gt;

&lt;p&gt;다음 포스트에서 오브젝트 파일에 대한 설명을 계속해 나가겠다. 또한 Go 런타임이 어떻게 작동하는 지를 이해하는데 필요한 정보들을 더 제공하겠다. 질문이 있다면 코멘트란에 부담없이 해 주길 바란다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;원문: &lt;a href=&#34;http://blog.altoros.com/golang-internals-part-3-the-linker-and-object-files.html&#34;&gt;Golang Internals, Part 3: The Linker, Object Files, and Relocations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;저자: Siarhei Matsiukevich&lt;/li&gt;
&lt;li&gt;번역자: Jhonghee Park&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golang의 내부, 2부: Go 컴파일러 들여다 보기</title>
      <link>https://golangkorea.github.io/post/golang-internals/part2/</link>
      <pubDate>Thu, 15 Sep 2016 05:53:48 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/golang-internals/part2/</guid>
      <description>

&lt;p&gt;독자는 인터페이스 레퍼런스를 통해 변수를 사용할 경우 Go 런타임내에서 어떤 일이 있는지 정확하게 알고 있는가? 이 질문에 쉽게 답할 수 없는 이유는 어떤 인터페이스를 구현하는 타입의 경우 그 인터페이스를 가리키는 어떤 레퍼런스도 갖고 있지 않기 때문이다. 하지만 여전히 시도는 해 볼 수 있는데 &lt;a href=&#34;https://golangkorea.github.io/post/golang-internals/part1/&#34;&gt;이전 블로그 포스트&lt;/a&gt;에서 논했던 Go 컴파일러의 지식을 이용하는 것이다.&lt;/p&gt;

&lt;p&gt;그러면, Go 컴파일러속으로 잠수해 들어가자: 간단한 Go 프로그램을 제작하고 Go 타입캐스팅(typecasting)이 내부적으로 어떻게 동작하는 지 살펴보겠다. 이 것을 예로 들면서, 어떻게 노드 트리가 생성되고 사용되는지 설명하겠다. 이렇게 함으로써 독자도 이 지식을 다른 Go 컴파일러 기능에 적용할 수 있을 것이다.&lt;/p&gt;

&lt;h1 id=&#34;시작하기-전에&#34;&gt;시작하기 전에&lt;/h1&gt;

&lt;p&gt;실험을 하기 전에, (Go 툴을 쓰는 것이 아니라) Go 컴파일러를 직접 사용할 필요가 있다. 다음 명령을 사용해 이 기능에 접근할 수 있다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;go tool 6g test.go
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 명령으로 &lt;em&gt;test.go&lt;/em&gt; 소스파일은 컴파일되고 오브젝트 파일(object file)이 만들어 진다. 여기서 &lt;em&gt;6g&lt;/em&gt; 는 AMD64 아키텍쳐인 저자의 머신을 위한 컴파일러의 이름이다. 다른 아키텍쳐에서는 상응하는 컴파일러를 사용해야 함을 주목하라.&lt;/p&gt;

&lt;p&gt;컴파일러를 직접 사용할 때 유용한 커맨드 라인 인수들을 사용할 수 있는데, 자세한 내용은 &lt;a href=&#34;https://golang.org/cmd/gc/#hdr-Command_Line&#34;&gt;여기&lt;/a&gt;를 참고하라. 이 실험을 위해서, 노드 트리의 레이아웃을 출력해 주는 &lt;em&gt;-W&lt;/em&gt; 플래그를 사용하겠다.&lt;/p&gt;

&lt;h1 id=&#34;간단한-go-프로그램-만들기&#34;&gt;간단한 Go 프로그램 만들기&lt;/h1&gt;

&lt;p&gt;우선 간단한 Go 프로그램을 만들자. 저자의 버전은 다음과 같다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  1  package main
  2
  3  type I interface {
  4          DoSomeWork()
  5  }
  6
  7  type T struct {
  8          a int
  9  }
 10
 11  func (t *T) DoSomeWork() {
 12  }
 13
 14  func main() {
 15          t := &amp;amp;T{}
 16          i := I(t)
 17          print(i)
 18  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;정말 간단하지 않은가? 불필요하게 생각되는 단 하나는 17째 줄인데, &lt;em&gt;i&lt;/em&gt; 변수를 출력하는 부분이다. 불필요하다고 판단됨에도 불구하고 이 줄이 없다면, &lt;em&gt;i&lt;/em&gt; 는 사용하지 않은 변수로 간주되어 프로그램은 컴파일 되지 않을 것이다. 다음 단계는 이 프로그램을 &lt;em&gt;-W&lt;/em&gt; 를 사용해 컴파일 하는 것이다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;go tool 6g -W test.go
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 명령을 실행한 후에, 프로그램내 정의된 각 메서드에 해당하는 노드 트리를 포함한 출력을 보게 될 것이다. 이 경우, &lt;em&gt;main&lt;/em&gt; 과 &lt;em&gt;init&lt;/em&gt; 메서드가 있다. &lt;em&gt;init&lt;/em&gt; 메서드가 언급된 이유는 모든 프로그램에 암시적으로 정의되어 있기 때문인데, 실제로 여기에서는 다루지 않겠다.&lt;/p&gt;

&lt;p&gt;각 메서드마다, 컴파일러는 두개의 노드트리 버전을 출력한다. 첫번째는 소스파일을 파싱하고 얻는 노드 트리의 원본이고 두번째는 타입체킹후 모든 필요한 수정을 거친 버전이다.&lt;/p&gt;

&lt;h1 id=&#34;main-메서드의-노드-트리에-대한-이해&#34;&gt;main 메서드의 노드 트리에 대한 이해&lt;/h1&gt;

&lt;p&gt;우선 main 메서드에서 나온 노드 트리의 원본을 자세히 들여다 보고 정확하게 무슨 일이 일어나고 있는지를 이해하기 위한 시도를 해보자.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;DCL l(15)
.   NAME-main.t u(1) a(1) g(1) l(15) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) PTR64-*main.T

AS l(15) colas(1) tc(1)
.   NAME-main.t u(1) a(1) g(1) l(15) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) PTR64-*main.T
.   PTRLIT l(15) esc(no) ld(1) tc(1) PTR64-*main.T
.   .   STRUCTLIT l(15) tc(1) main.T
.   .   .   TYPE &amp;lt;S&amp;gt; l(15) tc(1) implicit(1) type=PTR64-*main.T PTR64-*main.T

DCL l(16)
.   NAME-main.i u(1) a(1) g(2) l(16) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) main.I

AS l(16) tc(1)
.   NAME-main.autotmp_0000 u(1) a(1) l(16) x(0+0) class(PAUTO) esc(N) tc(1) used(1) PTR64-*main.T
.   NAME-main.t u(1) a(1) g(1) l(15) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) PTR64-*main.T

AS l(16) colas(1) tc(1)
.   NAME-main.i u(1) a(1) g(2) l(16) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) main.I
.   CONVIFACE l(16) tc(1) main.I
.   .   NAME-main.autotmp_0000 u(1) a(1) l(16) x(0+0) class(PAUTO) esc(N) tc(1) used(1) PTR64-*main.T

VARKILL l(16) tc(1)
.   NAME-main.autotmp_0000 u(1) a(1) l(16) x(0+0) class(PAUTO) esc(N) tc(1) used(1) PTR64-*main.T

PRINT l(17) tc(1)
PRINT-list
.   NAME-main.i u(1) a(1) g(2) l(16) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) main.I
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;아래 설명할 때는 불필요한 부분을 모두 제거한 요약한 버전을 사용하겠다.&lt;/p&gt;

&lt;p&gt;첫번째 노드는 꽤 단순하다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;DCL l(15)
.   NAME-main.t l(15) PTR64-*main.T
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;첫번째 노드는 선언 노드이다. &lt;em&gt;l(15)&lt;/em&gt; 는 노드가 줄 15에 정의되어 있음을 알려준다. 선언 노드는 &lt;em&gt;main.t&lt;/em&gt; 변수를 나타내는 이름 노드(name node)에 레퍼런스를 갖는다. 변수가 정의된 곳은 main 패키지이고 실제로 &lt;em&gt;main.T&lt;/em&gt; 타입를 가리키는 64비트 포인터이다. 15째 줄을 보면 어떤 선언이 되어 있는지 쉽게 이해할 수 있다.&lt;/p&gt;

&lt;p&gt;다음 것은 약간 까다롭다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;AS l(15)
.   NAME-main.t l(15) PTR64-*main.T
.   PTRLIT l(15) PTR64-*main.T
.   .   STRUCTLIT l(15) main.T
.   .   .   TYPE l(15) type=PTR64-*main.T PTR64-*main.T
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;최상위 노드(root node)는 할당(assignment) 노드이다. 첫번째 자식노드는 이름 노드(name node)로 &lt;em&gt;main.t&lt;/em&gt; 변수를 대표한다. 두번째 자식노드는 &lt;em&gt;main.t&lt;/em&gt; 에 할당되는, 포인터 리터럴 노드이다: &amp;amp;를 생각하라. 이 노드는 struct 리터럴 노드를 자식으로 갖고 있고, 그 노드는 또 실제 타입인 (&lt;em&gt;main.T&lt;/em&gt;)를 대표하는 타입 노드를 포인터로 가리킨다.&lt;/p&gt;

&lt;p&gt;다음 노드는 또 다른 선언이다. 이번에는 &lt;em&gt;main.I&lt;/em&gt; 타입에 속하는 &lt;em&gt;main.i&lt;/em&gt; 변수의 선언이다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;DCL l(16)
.   NAME-main.i l(16) main.I
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;그런 다음, 컴파일러는 또 다른 변수, &lt;em&gt;autotmp_0000&lt;/em&gt; 를 만들고, &lt;em&gt;main.t&lt;/em&gt; 변수를 할당한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;AS l(16) tc(1)
.   NAME-main.autotmp_0000 l(16) PTR64-*main.T
.   NAME-main.t l(15) PTR64-*main.T
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;마침내, 흥미로운 노드들에 도착했다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;AS l(16)
.   NAME-main.i l(16)main.I
.   CONVIFACE l(16) main.I
.   .   NAME-main.autotmp_0000 PTR64-*main.T
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기를 보면, 컴파일러가 &lt;em&gt;CONVIFACE&lt;/em&gt; 라고 불리는 특별한 노드를 &lt;em&gt;main.i&lt;/em&gt; 에 할당하는 것을 볼 수 있다. 하지만 이것만으로는 실제로 내부에서 어떤 일이 일어나는지 알 수 없다. 한가지 방법은 모든 모드 트리 수정이 적용되고 난 후에 main 메서드의 노드 트리속을 들여다 보는 것인데, 출력된 내용 중 &amp;ldquo;after walk main&amp;rdquo; 라는 섹션내의 정보를 통해 알아보는 것이다.&lt;/p&gt;

&lt;h1 id=&#34;컴파일러는-어떻게-할당노드를-번역하는가&#34;&gt;컴파일러는 어떻게 할당노드를 번역하는가&lt;/h1&gt;

&lt;p&gt;아래를 보면 컴파일러가 어떻게 할당 노드(assignment node)를 번역하는 지 알 수 있다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;AS-init
.   AS l(16)
.   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8
.   .   NAME-go.itab.*&amp;quot;&amp;quot;.T.&amp;quot;&amp;quot;.I l(16) PTR64-*uint8

.   IF l(16)
.   IF-test
.   .   EQ l(16) bool
.   .   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8
.   .   .   LITERAL-nil I(16) PTR64-*uint8
.   IF-body
.   .   AS l(16)
.   .   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8
.   .   .   CALLFUNC l(16) PTR64-*byte
.   .   .   .   NAME-runtime.typ2Itab l(2) FUNC-funcSTRUCT-(FIELD-
.   .   .   .   .   NAME-runtime.typ·2 l(2) PTR64-*byte, FIELD-
.   .   .   .   .   NAME-runtime.typ2·3 l(2) PTR64-*byte PTR64-*byte, FIELD-
.   .   .   .   .   NAME-runtime.cache·4 l(2) PTR64-*PTR64-*byte PTR64-*PTR64-*byte) PTR64-*byte
.   .   .   CALLFUNC-list
.   .   .   .   AS l(16)
.   .   .   .   .   INDREG-SP l(16) runtime.typ·2 G0 PTR64-*byte
.   .   .   .   .   ADDR l(16) PTR64-*uint8
.   .   .   .   .   .   NAME-type.*&amp;quot;&amp;quot;.T l(11) uint8

.   .   .   .   AS l(16)
.   .   .   .   .   INDREG-SP l(16) runtime.typ2·3 G0 PTR64-*byte
.   .   .   .   .   ADDR l(16) PTR64-*uint8
.   .   .   .   .   .   NAME-type.&amp;quot;&amp;quot;.I l(16) uint8

.   .   .   .   AS l(16)
.   .   .   .   .   INDREG-SP l(16) runtime.cache·4 G0 PTR64-*PTR64-*byte
.   .   .   .   .   ADDR l(16) PTR64-*PTR64-*uint8
.   .   .   .   .   .   NAME-go.itab.*&amp;quot;&amp;quot;.T.&amp;quot;&amp;quot;.I l(16) PTR64-*uint8
AS l(16)
.   NAME-main.i l(16) main.I
.   EFACE l(16) main.I
.   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8
.   .   NAME-main.autotmp_0000 l(16) PTR64-*main.T
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;출력을 통해 볼 수 있듯이, 컴파일러는 우선 초기화 노드 리스트 (&lt;em&gt;AS-init&lt;/em&gt;) 를 할당 노드에 첨가한다. &lt;em&gt;AS-init&lt;/em&gt; 내에서는, &lt;em&gt;go.itab.*””.T.””&lt;/em&gt;.I 변수 값을 새로 만든 변수 &lt;em&gt;main.autotmp_0003&lt;/em&gt; 에 할당한다. 그런 다음, 변수가 &lt;em&gt;nil&lt;/em&gt; 인지를 검사한다. 만약에 &lt;em&gt;nil&lt;/em&gt; 이면, 컴파일러는 &lt;em&gt;runtime.typ2Itab&lt;/em&gt; 함수를 다음의 인수들을 사용해 호출한다:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;main.T&lt;/em&gt; 타입의 포인터,&lt;/li&gt;
&lt;li&gt;&lt;em&gt;main.I&lt;/em&gt; 인터페이스 타입의 포인터,&lt;/li&gt;
&lt;li&gt;&lt;em&gt;go.itab.*””.T.””.I&lt;/em&gt; 변수를 가리키는 포인터.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;코드에서 보면, 이 변수가 &lt;em&gt;main.T&lt;/em&gt; 에서 &lt;em&gt;main.I&lt;/em&gt; 로 타입변환된 결과를 저장하는데 사용되고 있음이 명백하다.&lt;/p&gt;

&lt;h1 id=&#34;getitab-메서드의-내부&#34;&gt;&lt;em&gt;getitab&lt;/em&gt; 메서드의 내부&lt;/h1&gt;

&lt;p&gt;논리적인 다음 단계는 &lt;em&gt;runtime.typ2Itab&lt;/em&gt; 를 찾아보는 것이다. 아래에 이 함수를 나열해 놓았다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;func typ2Itab(t *_type, inter *interfacetype, cache **itab) *itab {
    tab := getitab(inter, t, false)
    atomicstorep(unsafe.Pointer(cache), unsafe.Pointer(tab))
    return tab
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;확실해 보이는 것은 실제 작업은 &lt;em&gt;getitab&lt;/em&gt; 메서드 내부에서 진행된다는 점인데, 두번째 줄에서 단순히 tab 변수를 cache 변수에 저장하는 점을 통해 알 수 있다. 그럼 &lt;em&gt;getitab&lt;/em&gt; 내부를 들여다 보자. 꽤 긴 내용이라 가장 들여다 볼 가치가 있는 부분만 복사했다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;m =
    (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*ptrSize, 0,
    &amp;amp;memstats.other_sys))
    m.inter = interm._type = typ

ni := len(inter.mhdr)
nt := len(x.mhdr)
j := 0
for k := 0; k &amp;lt; ni; k++ {
	i := &amp;amp;inter.mhdr[k]
	iname := i.name
	ipkgpath := i.pkgpath
	itype := i._type
	for ; j &amp;lt; nt; j++ {
		t := &amp;amp;x.mhdr[j]
		if t.mtyp == itype &amp;amp;&amp;amp; t.name == iname &amp;amp;&amp;amp; t.pkgpath == ipkgpath {
			if m != nil {
				*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;amp;m.fun[0]), uintptr(k)*ptrSize)) = t.ifn
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;우선 결과를 저장할 메모리를 할당한다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;(*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*ptrSize, 0, &amp;amp;memstats.other_sys))
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;Go 언어에서 왜 메모리를 할당하는지 그리고 왜 이렇게 이상한 방식으로 하는지 궁금해 진다. 이 질문에 답하기 위해 &lt;em&gt;itab&lt;/em&gt; struct 정의를 들여다 보아야 할 필요가 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;type itab struct {
	inter  *interfacetype
	_type  *_type
	link   *itab
	bad    int32
	unused int32
	fun    [1]uintptr // variable sized
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;마지막 특성인 &lt;em&gt;fun&lt;/em&gt; 은 요소가 하나인 배열로 정의되어 있다. 하지만 실제로 배열의 크기는 변할 수 있다고 코멘트되어 있다. 나중에 보겠지만 이 특성은 특정한 타입내 정의된 메서드들을 가리키는 포인터 배열를 가지고 있다. 이 메서드들은 인터페이스 타입의 메서드에 상응한다. Go 언어의 저자들은 이 특성을 위해 동적 메로리 할당을 사용한다. (그렇다, unsafe 패키지를 사용하면 이런 일들이 가능하다.) 메모리를 얼마나 할당해야 하는지는 struct 자체의 크기에 인터페이스내 메서드의 숫자에 포인터 크기를 곱한 값을 더해 계산할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*ptrSize
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;다음으로 두개의 중첩된 루프를 볼 수 있다. 첫째로 인터페이스의 모든 메서드를 차례로 처리한다. 인터페이스의 각 메서드에 대해서 특정한 타입내에 상응하는 메서드를 찾으려 한다. (메서드는 &lt;em&gt;mhdr&lt;/em&gt; 컬렉션에 저장되어 있다.) 두 메서드가 서로 같은지를 비교하는 과정은 굳이 설명할 필요가 없겠다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;if t.mtyp == itype &amp;amp;&amp;amp; t.name == iname &amp;amp;&amp;amp; t.pkgpath == ipkgpath
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;만약 매치를 찾으면, 결과값의 &lt;em&gt;fun&lt;/em&gt; 에 메서드를 가리키는 포인터를 저장한다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;amp;m.fun[0]), uintptr(k)*ptrSize)) = t.ifn
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;성능에 대해 짧게 언급하면: 인터페이스와 사전에 설정된 타입 정의에 대해 메서드는 알파벳 순서로 정렬되어 있어서, 이 중첩 루프는 *O(n * m)* 대신 &lt;em&gt;O(n + m)&lt;/em&gt; 으로 반복한다. n 과 m 은 상응하는 메서드 숫자들&lt;/p&gt;

&lt;p&gt;마지막으로, 할당의 마지막 부분을 기억하는가?&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;AS l(16)
.   NAME-main.i l(16) main.I
.   EFACE l(16) main.I
.   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8
.   .   NAME-main.autotmp_0000 l(16) PTR64-*main.T
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기에서 &lt;em&gt;EFACE&lt;/em&gt; 노드를 &lt;em&gt;main.i&lt;/em&gt; 변수에 할당한다. &lt;em&gt;EFACE&lt;/em&gt; 노드는 &lt;em&gt;main.autotmp_0003&lt;/em&gt; 와 &lt;em&gt;main.autotmp_0000&lt;/em&gt; 변수들에 대한 레퍼런스를 가지고 있는데 - &lt;em&gt;main.autotmp_0003&lt;/em&gt; 는 &lt;em&gt;runtime.typ2Itab&lt;/em&gt; 에 의해 반환된 itab struct를 가리키는 포인터이고, &lt;em&gt;main.autotmp_0000&lt;/em&gt; 변수는 &lt;em&gt;main.t&lt;/em&gt; 와 같은 값을 가지고 있다. 인터페이스 레퍼런스를 통해 메서드를 호출하는데 필요한 것은 이게 전부이다.&lt;/p&gt;

&lt;p&gt;그래서, &lt;em&gt;main.i&lt;/em&gt; 변수는 런타임 &lt;a href=&#34;https://godoc.org/runtime&#34;&gt;runtime&lt;/a&gt; 패키지내 정의된 &lt;a href=&#34;https://golang.org/src/runtime/iface.go&#34;&gt;iface&lt;/a&gt; struct의 인스턴스를 가지고 있다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;type iface struct {
    tab  *itab
    data unsafe.Pointer
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;다음에-살펴볼-내용은&#34;&gt;다음에 살펴볼 내용은?&lt;/h1&gt;

&lt;p&gt;저자가 지금까지 Go 컴파일러와 런타임에 대해 아주 작은 부분만 설명했다는 점을 이해한다. 얘기해 볼만한 흥미로운 주제들이 여전히 많이 남아있다. 예를 들면, 오브젝트 파일, 링커, 재배치(relocations), 등에 대해서는 다음 블로그 포스트에서 살펴보기로 하겠다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;원문: &lt;a href=&#34;http://blog.altoros.com/golang-internals-part-2-diving-into-the-go-compiler.html&#34;&gt;Golang Internals, Part 2: Diving Into the Go Compiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;저자: Siarhei Matsiukevich&lt;/li&gt;
&lt;li&gt;번역자: Jhonghee Park&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golang의 내부, 1부: 주요 컨셉트와 프로젝트 구조</title>
      <link>https://golangkorea.github.io/post/golang-internals/part1/</link>
      <pubDate>Tue, 13 Sep 2016 13:18:28 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/golang-internals/part1/</guid>
      <description>

&lt;p&gt;이 블로그 시리즈는 기본적인 Go 언어특성에 이미 익숙하며 좀 더 심도있게 내부구조를 알고자 하는 독자들을 위해 쓰여졌다. 이 포스트는 Go언어의 소스코드의 구조와 Go 컴파일러의 내부를 어느 정도 상세히 살펴보겠다. 이 글을 읽고 난 후, 독자는 다음과 같은 질문에 답을 얻을 것이다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Go의 소스코드는 어떤 구조를 가지고 있는가?&lt;/li&gt;
&lt;li&gt;Go의 컴파일러는 어떻게 동작하는가?&lt;/li&gt;
&lt;li&gt;Go의 노드 트리(node treee)의 기본 구조는 무엇인가?&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;시작하며&#34;&gt;시작하며&lt;/h1&gt;

&lt;p&gt;새로운 프로그래밍 언어를 배우기 시작할 때, 보통은 &amp;ldquo;hello-world&amp;rdquo;와 같은 튜토리얼이나, 초보자 가이드, 그리고 언어의 주요한 컨셉트, 문법, 심지어 표준 라이브러리에 대한 상세한 정보들 많이 접하게 된다. 하지만, 언어가 런타임 도중에 할당하는 주요한 데이터 구조의 레이아웃이라던지, 내장 함수를 호출할 때 어떤 어셈블리 코드가 발생하는지와 같은 정보를 얻는 것은 쉽지 않다. 물론, 답은 소스코드내에 자리잡고 있지만, 저자의 경험에 비추어 보면, 이렇다 할 성과없이 수많은 시간을 허비하는 일도 가능하다.&lt;/p&gt;

&lt;p&gt;이런 주제에 대해 전문가인 척 하지도 않을 거고, 모든 가능한 측면을 설명하려는 시도 또한 하지 않겠다. 대신, 목표하는 바는 독자들 스스로 Go 소스코드를 어떻게 해독해 나갈 수 있는 지를 보여주는 것이다.&lt;/p&gt;

&lt;p&gt;시작하기 전에, 반드시 필요한 것은 각자의 Go 소스코드 복사본을 갖는 것이다. 소스코드를 다운 받는데 특별할 게 전혀 없다. 다음 명령을 실행해 보자.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/golang/go
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;메인 브랜치의 코드는 상시 변하는 점을 주목하자. 그래서 저자는 이 블로그에서 release-branch.go1.4 브랜치를 사용한다.&lt;/p&gt;

&lt;h1 id=&#34;프로젝트-구조-이해하기&#34;&gt;프로젝트 구조 이해하기&lt;/h1&gt;

&lt;p&gt;Go 레포의 &lt;code&gt;/src&lt;/code&gt; 폴더를 보게 되면, 많은 폴더를 발견하게 된다. 대부분은 Go의 표준 라이브러리 소스 파일을 갖고 있다. 여기에도 표준 이름짓기 관행이 항상 적용되는데, 각 패키지는 그 이름에 상응하는 이름의 폴더 아래 있다. 표준 라이브러리외에 다른 것들을 살펴보자. 저자의 견해로는, 아래 폴더들이 가장 중요하고 유용하다.&lt;/p&gt;

&lt;style type=&#34;text/css&#34;&gt;&lt;!--
.myTable { background-color:white;border-collapse:collapse; } .myTable th { background-color:#E0E0E0;color:black; } .myTable td, .myTable th { padding:5px;border:1px solid #989898; }
--&gt;&lt;/style&gt;

&lt;table class=&#34;myTable&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;&lt;center&gt;폴더&lt;/center&gt;&lt;/th&gt;
&lt;th style=&#34;width: 530px;&#34; width=&#34;70%&#34;&gt;&lt;center&gt;설명&lt;/center&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/golang/go/tree/release-branch.go1.4/src/cmd&#34; target=&#34;golangsrc&#34;&gt;/src/cmd/&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;코멘드 라인 툴들을 보관한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/golang/go/tree/release-branch.go1.4/src/cmd/go&#34; target=&#34;golangsrc&#34;&gt;/src/cmd/go/&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Go 툴의 소스 파일이 있는데, 이 툴들은 Go 소스코드를 다운받거나, 빌드하고, 설치하는데 사용된다. 툴이 실행되면서 전체 소스를 수집하고, Go 링커와 컴파일러 코멘드 라인 툴들을 호출한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/golang/go/tree/release-branch.go1.4/src/cmd/dist&#34; target=&#34;golangsrc&#34;&gt;/src/cmd/dist/ &lt;/a&gt;&lt;/td&gt;
&lt;td&gt;다른 코멘트 라인 툴과 표준 라이브러리의 모든 패키지를 빌드하는 툴을 보관한다. 모든 특정한 툴이나 패키지에서 어떤 라이브러리가 사용되었는지를 알아 보려면 이 소스를 분석하고 싶을 것이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/golang/go/tree/release-branch.go1.4/src/cmd/gc&#34; target=&#34;golangsrc&#34;&gt;/src/cmd/gc/&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Go 컴파일러내 (프로세서) 아키텍쳐에 의존하지 않는 부분이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/golang/go/tree/release-branch.go1.4/src/cmd/ld&#34; target=&#34;golangsrc&#34;&gt;/src/cmd/ld/&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Go 링커내 (프로세서) 아키텍쳐에 의존하지 않는 부분이다. 아키텍쳐에 의존적인 부분들은 &#34;l&#34;로 끝나는 이름의 폴더에 위치하며 컴파일러와 같은 이름짓기 관행을 따른다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/golang/go/tree/release-branch.go1.4/src/cmd/5a&#34; target=&#34;golangsrc&#34;&gt;/src/cmd/5a/&lt;/a&gt;, 6a, 8a, and 9a&lt;/td&gt;
&lt;td&gt;여러 아키텍쳐에 맞춘 Go 어셈블러 컴파일러들을 발견할 수 있다. Go 어셈블러는 일종의 어셈블리 언어로 하층 기계어와는 딱 맞아 떨어지는 것은 아니다. 대신 각 아키텍쳐마다 독특한 컴파일러들이 있어 Go의 어셈블러를 기계의 어셈블러도 번역한다. 더 자세한 내용은 다음 링크를 참조하라. &lt;a href=&#34;https://golang.org/doc/asm&#34; target=&#34;golangsrc&#34;&gt;여기&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/golang/go/tree/release-branch.go1.4/src/lib9&#34; target=&#34;golangsrc&#34;&gt;/src/lib9/&lt;/a&gt;, &lt;a href=&#34;https://github.com/golang/go/tree/release-branch.go1.4/src/libbio&#34; target=&#34;golangsrc&#34;&gt;/src/libbio&lt;/a&gt;, &lt;a href=&#34;https://github.com/golang/go/tree/release-branch.go1.4/src/liblink&#34; target=&#34;golangsrc&#34;&gt;/src/liblink&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;컴파일러, 링커, 그리고 런타임 패키지에 사용된 각종 라이브러리들.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/golang/go/tree/release-branch.go1.4/src/runtime&#34; target=&#34;golangsrc&#34;&gt;/src/runtime/&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;가장 중요한 Go 패키지로 모든 프로그램에 간접적으로 포함된다. 메모리 관리, 가비지 콜렉션, Go 루틴 생산등, 런타임 기능 전체를 포함하고 있다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;컴파일러-내부&#34;&gt;컴파일러 내부&lt;/h1&gt;

&lt;p&gt;위에서 언급한 것 처럼, 아키텍쳐에 무관한 Go 컴파일러는 &lt;code&gt;/src/cmd/gc&lt;/code&gt; 폴더에 위치 한다. 시작 점은 &lt;code&gt;lex.c&lt;/code&gt; 파일에 있다. 코멘드 라인 인수 파싱 같은 보편적인 기능들을 차치하고 들여다 보면, 컴파일러는 다음과 같은 일들을 한다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;어떤 공통의 데이터 구조를 초기화 한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;주어진 모든 Go 파일을 차례로 읽어서 각 파일에 yyparse 메서드를 호출한다. 이때 실제로 파싱이 작동한다. Go 컴파일러는 &lt;code&gt;Bison&lt;/code&gt;을 파서 발생기(parser generator)로 사용한다. 언어의 문법은 &lt;a href=&#34;https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.y&#34;&gt;go.y&lt;/a&gt;에 완전히 서술되어 있다. (자세한 내용은 나중에 더 제공될 예정이다) 결과로, 이 단계는 완전한 파스트리(parse tree)를 생성하는데, 이때 트리의 각 노드는 컴파일된 프로그램의 요소들을 대표한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;생성된 트리를 재귀적으로(Recursively) 방문하면서 약간의 수정을 가한다, 예를 들어, 암시적으로 타입이 주어진 노드에 타입 정보를 정의하거나, 타입 케스팅과 같은 언어요소들을 런타임 패키지내 어떤 함수을 호출하는 식으로 다시 재구성하기도 한다 그외 다른 일들도 실행한다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;파스트리(parse tree)가 완성되고 난 뒤 실제 컴파일을 실행한다. 노드들은 어셈블리 코드로 번역된다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;생성된 어셈블리 코드에 심볼 테이블과 같은 부수적인 데이터 구조를 함께 오브젝트 파일 (object file)에 담아 만들고 디스크에 저장한다.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;go-문법-들여다-보기&#34;&gt;Go 문법 들여다 보기&lt;/h1&gt;

&lt;p&gt;이제 두번째 단계를 좀 더 가까이 살펴보자. &lt;a href=&#34;https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.y&#34;&gt;go.y&lt;/a&gt; 파일은 언어 문법(grammar)을 가지고 있어 Go 컴파일러를 조사하고 언어의 구문론(syntax)을 이해하는 데 좋은 출발점이다. 파일의 주요한 부분은 선언문들로 구성되며, 다음과 유사하다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;xfndcl:
     LFUNC fndcl fnbody

fndcl:
     sym &#39;(&#39; oarg_type_list_ocomma &#39;)&#39; fnres
| &#39;(&#39; oarg_type_list_ocomma &#39;)&#39; sym &#39;(&#39; oarg_type_list_ocomma &#39;)&#39; fnres
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 선언에서는, &lt;em&gt;xfndcl&lt;/em&gt; 와 &lt;em&gt;fundcl&lt;/em&gt; 노드가 정의된다. &lt;em&gt;fundcl&lt;/em&gt; 노드는 두가지 형식중에 하나이다. 첫번째는 다음의 언어 구성소(construct)에 상응하는 형식이다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;somefunction(x int, y int) int
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;그리고 두번째는 다음의 언어 구성소에 상응한다:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;(t *SomeType) somefunction(x int, y int) int.
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;xfndcl&lt;/em&gt; 노드는 상수인 &lt;em&gt;LFUNC&lt;/em&gt; 에 저장된 키워드 &lt;em&gt;func&lt;/em&gt; 를 뒤 따르는 &lt;em&gt;fndcl&lt;/em&gt; 와 &lt;em&gt;fnbodynodes&lt;/em&gt; 로 구성되어 있다.&lt;/p&gt;

&lt;p&gt;Bison(혹은 Yacc) 문법의 중요한 기능중에 하나는 무작위의 C 코드를 각 노드 정의옆에 갖다 붙일 수 있다는 것이다. 소스 코드안에 이런 노드의 정의가 매치될 때 마다 C 코드는 실행된다. 여기서, (실행된)결과의 노드는 $$ 사용해 표시하고 $1, $2 등등으로 자식 노드를 나타낸다.&lt;/p&gt;

&lt;p&gt;예제를 통해 보면 다 쉽게 이해할 수 있다. 다음은 실제코드를 간소한 예다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;fndcl:
      sym &#39;(&#39; oarg_type_list_ocomma &#39;)&#39; fnres
        {
          t = nod(OTFUNC, N, N);
          t-&amp;gt;list = $3;
          t-&amp;gt;rlist = $5;

          $$ = nod(ODCLFUNC, N, N);
          $$-&amp;gt;nname = newname($1);
          $$-&amp;gt;nname-&amp;gt;ntype = t;
          declare($$-&amp;gt;nname, PFUNC);
      }
| &#39;(&#39; oarg_type_list_ocomma &#39;)&#39; sym &#39;(&#39; oarg_type_list_ocomma &#39;)&#39; fnres
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;우선, 새로운 노드가 만들어 지고 함수 선언을 위한 타입 정보를 갖는다. $3는 인수 리스트로 $5는 결과 리스트로 이 노드에서 레퍼런스된다. 그런 다음, $$ 결과 노드가 만들어 져서, 함수 이름과, 타입 노드를 저장한다. 보다시피 &lt;a href=&#34;https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.y&#34;&gt;go.y&lt;/a&gt;내 정의된 것들과 노드 구조사이에 직접적인 연결이 있을 수 없다.&lt;/p&gt;

&lt;h1 id=&#34;노드-이해하기&#34;&gt;노드 이해하기&lt;/h1&gt;

&lt;p&gt;이제 노드가 실제로 무엇인지 알아 볼 시간이다. 첫번째로, 노드는 struct이고, &lt;a href=&#34;https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.h#L245&#34;&gt;여기&lt;/a&gt;에 정의되어 있다. 이 struct는 굉장히 많은 특성들을 갖고 있는데 그 이유는 다른 종류의 노드를 지원해야 하고 노드종류마다 다른 속성들을 가지고 있기 때문이다.&lt;/p&gt;

&lt;table class=&#34;myTable&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;&lt;center&gt;노드 struct 필드&lt;/center&gt;&lt;/th&gt;
&lt;th style=&#34;width: 530px;&#34; width=&#34;70%&#34;&gt;&lt;center&gt;설명&lt;/center&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.h#L259&#34; target=&#34;golangsrc&#34;&gt;op&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;이 필드는 각 노드마다 존재하며 노드의 연산이 무엇이지를 나타낸다. 이 필드를 통해 노드의 종류를 분간할 수 있다. 이전 예제에서 본 &lt;em&gt;OTFUNC&lt;/em&gt; (연산 타입 함수) 과 &lt;em&gt;ODCLFUNC&lt;/em&gt; (연산 선언 함수)같은 것 들이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.h#L295&#34; target=&#34;golangsrc&#34;&gt;type&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;노드가 타입정보를 보유할 때 (때로 타입이 없는 노드도 있다. 예를 들면, &lt;em&gt;if&lt;/em&gt;, &lt;em&gt;switch&lt;/em&gt;, 혹은 &lt;em&gt;for&lt;/em&gt;와 같은 제어 흐름문들), 이 필드는 타입정보를 가지고 있는 또 다른 struct를 가리키는 레퍼런스이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/golang/go/blob/release-branch.go1.4/src/cmd/gc/go.h#L309&#34; target=&#34;golangsrc&#34;&gt;val&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;이 필드는 리터럴 노드의 실제 값을 갖는다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;독자는 이제 노드 트리의 기본적 구조를 이해했으므로, 그 지식을 실전에 투여할 수 있다. 다음 포스트에서는, Go 컴파일러가 과연 무엇을 생산하는지를 간단한 Go 애플리케이션을 통해 살펴보겠다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;원문: &lt;a href=&#34;http://blog.altoros.com/golang-part-1-main-concepts-and-project-structure.html&#34;&gt;Golang Internals, Part 1: Main Concepts and Project Structure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;저자: Siarhei Matsiukevich&lt;/li&gt;
&lt;li&gt;번역자: Jhonghee Park&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golang의 내부, 0부: 부록</title>
      <link>https://golangkorea.github.io/post/golang-internals/resources/</link>
      <pubDate>Mon, 12 Sep 2016 13:18:28 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/golang-internals/resources/</guid>
      <description>

&lt;h1 id=&#34;go-언어의-최신-컴파일러에-대한-내용&#34;&gt;Go 언어의 최신 컴파일러에 대한 내용&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;GopherCon 2016: Rob Pike - The Design of the Go Assembler

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=KINIAgRpkDA&#34;&gt;Video&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://talks.golang.org/2016/asm.slide&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;GopherCon 2014 Go from C to Go by Russ Cox

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=QIE5nV5fDwA&#34;&gt;Video&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://talks.golang.org/2014/c2go.slide&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;GopherFest 2015: Rob Pike on the move from C to Go in the toolchain

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=cF1zJYkBW4A&#34;&gt;Video&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://talks.golang.org/2015/gogo.slide&#34;&gt;Slides&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;go의-어셈블러&#34;&gt;Go의 어셈블러&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/asm&#34;&gt;A Quick Guide to Go&amp;rsquo;s Assembler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>시리즈 #5 - 사이트에 블로그 올리는 방법</title>
      <link>https://golangkorea.github.io/post/hugo-intro/how-to-contribute-content/</link>
      <pubDate>Tue, 23 Aug 2016 23:25:55 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/hugo-intro/how-to-contribute-content/</guid>
      <description>

&lt;h1 id=&#34;사이트에-블로그-올리는-방법&#34;&gt;사이트에 블로그 올리는 방법&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://golangkorea.github.io&#34;&gt;Golang Korean Community 사이트&lt;/a&gt;는 깃헙의 &lt;a href=&#34;https://github.com/golangkorea&#34;&gt;golangkorea&lt;/a&gt; Organization의 웹사이트로 &lt;a href=&#34;https://pages.github.com/&#34;&gt;GitHub Pages&lt;/a&gt;를 이용해 제작되고 있습니다. 현존하는 Static Site Generator중 가장 빠른 Hugo를 엔진으로 사용하고 주로 Go언어에 관련된 포스트와 글로벌 기술 동향및 최신의 개발 기법등을 소개하는 포스트를 다루고 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;참여자격&#34;&gt;참여자격&lt;/h1&gt;

&lt;p&gt;깃헙에 계정이 있는 개발자라면 누구나 제작에 참여하실 수 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;fork-it&#34;&gt;Fork it!&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://golangkorea.github.io&#34;&gt;Golang Korean Community 사이트&lt;/a&gt;는 다음과 같이 두개의 Repo를 가지고 개발됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/golangkorea/golangkorea-hugo&#34;&gt;golangkorea-hugo&lt;/a&gt;&lt;/strong&gt; Hugo로 제작하는 golangkorea.github.io의 소스 프로젝트입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/golangkorea/golangkorea.github.io&#34;&gt;golangkorea.github.io&lt;/a&gt;&lt;/strong&gt; golangkorea-hugo의 submodule로 Hugo로 빌드된 웹사이트입니다. 직접 이 repo에서 작업하지는 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;포스트를 하기 위해서 우선 githubkorea-hugo를 fork하신다음 본인의 repo를 clone하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/myaccount/golangkorea-hugo.git
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;clone-hugo-octopress&#34;&gt;clone hugo-octopress&lt;/h1&gt;

&lt;p&gt;미래에는 어떻게 바뀔지 모르겠지만 현재 golangkorea.github.io는 &lt;a href=&#34;https://github.com/parsiya/Hugo-Octopress&#34;&gt;hugo-octopress&lt;/a&gt; 테마를 사용하고 있습니다. &lt;code&gt;themes&lt;/code&gt; 폴더에 clone하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd themes
$ git clone https://github.com/parsiya/Hugo-Octopress.git
$ cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;start-hugo&#34;&gt;Start Hugo&lt;/h1&gt;

&lt;p&gt;이제 로컬에서 사이트를 열어볼 차례입니다. 다음 명령을 사용해서 Hugo의 웹서버를 시작하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313&#34;&gt;http://localhost:1313&lt;/a&gt;를 브라우저에 열어서 사이트가 뜨는 걸 확인하십시요.&lt;/p&gt;

&lt;h1 id=&#34;첫번째-포스트&#34;&gt;첫번째 포스트&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;hugo new&lt;/code&gt;명령을 사용해서 포스트의 작성을 시작하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new post/my-frist-blog.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;golangkorea.github.io는 &lt;code&gt;authors&lt;/code&gt; taxonomy를 지원합니다. 포스트의 Front Matter에 다름과 같이 저자의 영어 이름을 입력해 주십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2016-08-28T23:01:25-04:00&amp;quot;
draft = true
title = &amp;quot;my first post&amp;quot;

authors = [&amp;quot;Your Name&amp;quot;]
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;golangkorea.github.io는 저자의 소개 페이지를 지원합니다. 다름과 같이 본인의 이름을 hyphenated, lower-cased된 형태로 만들어 주십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new author/your-name.md
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;pull-request하기&#34;&gt;Pull Request하기&lt;/h1&gt;

&lt;p&gt;포스트의 작성이 끝나면 다음 과정을 거쳐 Pull Request해 주십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add -A
...
$ git commit -m&amp;quot;My first post&amp;quot;
...
$ git push
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pull Request에 대한 자세한 내용은 &lt;a href=&#34;https://help.github.com/articles/about-pull-requests/&#34;&gt;GitHub의 도움말&lt;/a&gt;을 참조 하세요.&lt;/p&gt;

&lt;h1 id=&#34;최신의-golankorea-hugo-repo와-싱크하기&#34;&gt;최신의 golankorea-hugo repo와 싱크하기&lt;/h1&gt;

&lt;p&gt;포스트를 한 지 좀 시간이 지나다 보면 그 사이에 사이트에 많은 변화가 있을 수 있습니다. 그때는 본인의 로컬 repo를 최신의 golangkorea-hugo와 싱크 시킬 필요가 생깁니다. 새로운 포스트를 시작하기 전에 우선 로컬의 repo에 golangkorea-hugo를 upstream remote repo로 만드시고 나머지 단계를 따라 싱크 시키십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Add the remote, call it &amp;quot;upstream&amp;quot;:

git remote add upstream https://github.com/golangkorea/golangkorea-hugo.git

# Fetch all the branches of that remote into remote-tracking branches,
# such as upstream/master:

git fetch upstream

# Make sure that you&#39;re on your master branch:

git checkout master

# Rewrite your master branch so that any commits of yours that
# aren&#39;t already in upstream/master are replayed on top of that
# other branch:

git rebase upstream/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Merge를 하는 경우에는 &lt;code&gt;rebase&lt;/code&gt;를 &lt;code&gt;merge&lt;/code&gt;로 바꿔주시면 됩니다. &lt;a href=&#34;https://help.github.com/articles/syncing-a-fork/&#34;&gt;깃헙의 공식 도움말&lt;/a&gt;을 참조하십시요&lt;/p&gt;

&lt;p&gt;일단 싱크되면 본인의 forked repo에 다시 푸쉬하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git push -f origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 새로운 포스트를 작성하십시요.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>시리즈 #4 - 분류(Taxonomy)기능 사용하기</title>
      <link>https://golangkorea.github.io/post/hugo-intro/taxonomy-basic/</link>
      <pubDate>Tue, 23 Aug 2016 23:25:44 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/hugo-intro/taxonomy-basic/</guid>
      <description>

&lt;h1 id=&#34;분류-taxonomy-기능-사용하기&#34;&gt;분류(Taxonomy)기능 사용하기&lt;/h1&gt;

&lt;p&gt;사이트에 컨텐트가 많아 질 수록 고민이 생깁니다. 비숫한 주제의 컨텐트를 한 곳에 나열해 주는 페이지를 만들수는 없는가? 순진한 저자는 자기가 포스트한 내용을 모두 한 포스트에 링크할 지도 모릅니다. 주제 별로 나열해 주는 포스트를 만들어 새로운 포스트가 올라올 때 마다 링크를 걸어 줄 수도 있겠죠. 손이 많이 가고 더군다나 다른 저자들의 비슷한 포스트는 포함되지 못하는 일도 허다할 겁니다.&lt;/p&gt;

&lt;p&gt;Hugo는 이런 문제를 분류(taxonomy)라는 기능으로 간단히 햬결해 드립니다.&lt;a href=&#34;#footnote-1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 기본적으로 Hugo에는 &lt;code&gt;tags&lt;/code&gt;와 &lt;code&gt;categories&lt;/code&gt;라는 분류변수를 지원합니다. 컨텐트 저자가 할 일은 단지 Front Matter에 명시해 주기만 하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2016-08-23T23:25:44-04:00&amp;quot;
draft = false
title = &amp;quot;시리즈 #4 - 분류(Taxonomy)기능 사용하기&amp;quot;

tags = [&amp;quot;Blog&amp;quot;, &amp;quot;Hugo&amp;quot;]
categories = [&amp;quot;How-to&amp;quot;]
series = [&amp;quot;Hugo Introduction&amp;quot;]
authors = [&amp;quot;Jhonghee Park&amp;quot;]

toc = true
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예를 들어 &lt;code&gt;How-to&lt;/code&gt; category의 경우 Hugo는 모든 컨텐트를 스캔하면서 해당 컨텐트들을 &lt;code&gt;/categories/how-to/index.html&lt;/code&gt;로 나열해 줍니다. 다시 말하면 taxonomy기능이 컨텐트내에 사용되면 taxonomy에 지정된 template을 이용해 Hugo는 모든 taxonomy페이지를 자동으로 만들고 사용된 term과 각 term을 사용한 컨텐트를 나열합니다.&lt;/p&gt;

&lt;h1 id=&#34;taxonomy-용어-정리&#34;&gt;Taxonomy 용어 정리&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Taxonomy&lt;/strong&gt; 같은 카테고리의 컨텐트를 분류하는 방식 (예: tag, category, author 등)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Term&lt;/strong&gt; taxonomy에 속하는 키워드 (author의 예를 들면 &lt;code&gt;Jhonghee Park&lt;/code&gt;, &lt;code&gt;Sangbae Yun&lt;/code&gt;, &lt;code&gt;Kookheon Kwon&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Value&lt;/strong&gt; term이 사용된 컨텐트의 내용&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;taxonomy-organization&#34;&gt;Taxonomy Organization&lt;/h1&gt;

&lt;p&gt;Taxonomy의 관점에서 본 Organization은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ascii&#34;&gt;author                                     &amp;lt;-- Taxonomy
    Jhonghee Park                          &amp;lt;-- Term
        ReadMe First                       &amp;lt;-- Content
        시리즈 #1 - Hugo 시작하기           &amp;lt;-- Content
        시리즈 #2 - 컨텐츠 제작 기초         &amp;lt;-- Content
        ...
    Sangbae Yun                            &amp;lt;-- Term
        Go언어 시작하기                    &amp;lt;-- Content
        Golang 프로젝트에 TDD 도입하기      &amp;lt;-- Content
        vim-go를 이용한 go 개발 환경 구축   &amp;lt;-- Content
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;컨텐트의 관점에서 본 Organization은 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ascii&#34;&gt;시리즈 #1 - Hugo 시작하기      &amp;lt;-- Content
    author                    &amp;lt;-- Taxonomy
        Jhonghee Park         &amp;lt;-- Term
    series                    &amp;lt;-- Taxonomy
        Hugo 입문             &amp;lt;-- Term
Go언어 시작하기                &amp;lt;-- Content
    author                    &amp;lt;-- Taxonomy
        Sangbae Yun           &amp;lt;-- Term
    series                    &amp;lt;-- Taxonomy
        Go 시작하기            &amp;lt;-- Term
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;분류변수-taxonomies-의-정의&#34;&gt;분류변수(taxonomies)의 정의&lt;/h1&gt;

&lt;p&gt;분류변수는 사용하기 전에 사이트 configuration에 정의되어야 만 합니다. 단수형과 복수형을 사용해 다음과 같이 정의합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[taxonomies]
author = &amp;quot;authors&amp;quot;
category = &amp;quot;categories&amp;quot;
tag = &amp;quot;tags&amp;quot;
series = &amp;quot;series&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;컨텐트에-분류변수-지정하기&#34;&gt;컨텐트에 분류변수 지정하기&lt;/h1&gt;

&lt;p&gt;일단 분류변수가 사이트 레벨에 정의된 후에는 컨텐트 타입과 &lt;code&gt;section&lt;/code&gt;을 막론하고 어떤 컨텐트에도 사용 가능합니다. Front Matter에 복수형의 taxonomies를 써서 원하는 모든 Term을 나열하면 됩니다.&lt;/p&gt;

&lt;h1 id=&#34;taxonomy-템플릿&#34;&gt;Taxonomy 템플릿&lt;/h1&gt;

&lt;p&gt;Hugo는 일정한 규칙에 따라 Taxonomy 리스트 페이지를 만들어 냅니다. 주어진 Term의 모든 Taxonomy Value 리스트는 다음과 같은 URL 형식을 따릅니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/{{복수형 Taxonomy 이름}}/{{Term}}/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이때 Term은 다음과 같은 변환을 거칩니다&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;hyphenated&lt;/strong&gt; &lt;code&gt;How to&lt;/code&gt;는 &lt;code&gt;/categories/how-to&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lower-cased&lt;/strong&gt; &lt;code&gt;Jhonghee Park&lt;/code&gt;는 &lt;code&gt;/authors/jhonghee-park&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;normalized&lt;/strong&gt; &lt;code&gt;Gérard Depardieu&lt;/code&gt;는 &lt;code&gt;/actors/gerard-depardieu&lt;/code&gt;&lt;a href=&#34;#footnote-2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Taxonomy 페이지를 렌더링하기 위해서는 해당 Taxonomy의 템플릿이 필요합니다. 템프릿의 위치는 다음의 규칙을 따릅니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/layouts/taxonomy/{{단수형 Taxonomy 이름}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Taxonomy, &lt;code&gt;authors&lt;/code&gt;의 경우, 템플릿은 &lt;code&gt;/layouts/taxonomy/author.html&lt;/code&gt;에 위치하게 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
&lt;hr/&gt;
&lt;br/&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a id=&#34;footnote-1&#34;&gt;&lt;/a&gt;Hugo v0.11이전에는 taxonomies를 indexes로 불렀습니다. 그런 이유로 만들어 진지 오래된 테마의 taxonomies 템플릿들은 &lt;code&gt;layouts/indexes&lt;/code&gt;에 위치 할 수도 있습니다.&lt;/li&gt;
  &lt;li&gt;Special Character를 보존하고자 하면 사이트 Configuraton에 &lt;code&gt;preserveTaxonomyNames = true&lt;/code&gt;를 지정해야 합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>시리즈 #3 - 사이트 테마 개발하기</title>
      <link>https://golangkorea.github.io/post/hugo-intro/theme-customizing/</link>
      <pubDate>Tue, 23 Aug 2016 23:25:30 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/hugo-intro/theme-customizing/</guid>
      <description>

&lt;h1 id=&#34;사이트-테마-개발하기&#34;&gt;사이트 테마 개발하기&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/getting-started&#34;&gt;시리즈 1&lt;/a&gt; 마지막에 &lt;a href=&#34;http://themes.gohugo.io/hugo-octopress/&#34;&gt;hugo-octopress&lt;/a&gt; 테마를 사용하여 처음으로 사이트를 구축한 기억을 하실 겁니다. 사이트를 구축하기 전에 Hugo에서 사용할 수 있는 테마가 어떤것 있는지 한번 살펴보고 생각하고 있는 사이트와 잘 맞는 테마를 선택하는 일도 중요합니다. Hugo의 테마 쇼케이스에서 한번 감상하시길 바랍니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://themes.gohugo.io/&#34;&gt;Hugo 테마 쇼케이스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자신만의 테마를 개발하기 위한 첫걸음은 남이 개발해 놓은 테마를 사용하는 것에서 부터 시작합니다.&lt;/p&gt;

&lt;h1 id=&#34;테마-설치하는-법&#34;&gt;테마 설치하는 법&lt;/h1&gt;

&lt;p&gt;테마의 사용법은 대단히 간단합니다. &lt;code&gt;hugo new site&lt;/code&gt;명령으로 사이트 프로젝트를 초기화하면 &lt;code&gt;themes&lt;/code&gt; 폴더가 생기는 것을 이미 아실 것입니다. 사용하고자 하는 테마를 선택하고 난 뒤 &lt;code&gt;themes&lt;/code&gt; 폴더 밑에 다운로드 받은 테마 패키지를 설치해 주면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테마의 깃헙주소를 아는 경우&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd themes
$ git clone https://github.com/parsiya/Hugo-Octopress.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;테마 쇼케이스의 모든 테마를 설치하는 경우&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone --recursive https://github.com/spf13/hugoThemes.git themes
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;테마-사용법&#34;&gt;테마 사용법&lt;/h1&gt;

&lt;p&gt;테마를 &lt;code&gt;themes&lt;/code&gt;에 설치하고 난 뒤 다음과 같이 선택한 테마로 사이트를 구축할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo -t ThemeName
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ThemeName은 &lt;code&gt;themes&lt;/code&gt; 폴더내 설치된 테마의 디렉토리 이름과 일치하여야 합니다.&lt;/p&gt;

&lt;h1 id=&#34;테마-커스터마이징&#34;&gt;테마 커스터마이징&lt;/h1&gt;

&lt;p&gt;설치된 테마를 사용하다 보면 맘에 들지 않는 부분이 생기거나 부족한 부분을 발견할 지도 모릅니다. &lt;strong&gt;&lt;em&gt;어떤 경우가 생기더라도 &lt;code&gt;themes&lt;/code&gt;밑에 설치된 테마에 속한 파일들을 직접 편집하지 마십시요&lt;/em&gt;&lt;/strong&gt;. Hugo는 이러한 경우가 생길때 보충하거나 기존의 템플릿을 오버라이드할 수 있도록 허락합니다. 설치된 테마의 구조를 살펴보시면 힌트를 얻을 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
└── Hugo-Octopress
    ├── LICENSE.md
    ├── README.md
    ├── images
    │   ├── Thumbs.db
    │   ├── codecaption1.png
    │   ├── screenshot.png
    │   └── tn.png
    ├── layouts
    │   ├── 404.html
    │   ├── _default
    │   │   ├── list.html
    │   │   ├── single.html
    │   │   └── terms.html
    │   ├── index.html
    │   ├── indexes
    │   │   ├── category.html
    │   │   └── tag.html
    │   ├── license
    │   │   └── single.html
    │   ├── partials
    │   │   ├── disqus.html
    │   │   ├── footer.html
    │   │   ├── header.html
    │   │   ├── navigation.html
    │   │   ├── octo-header.html
    │   │   ├── pagination.html
    │   │   ├── post_footer.html
    │   │   ├── post_header.html
    │   │   └── sidebar.html
    │   ├── post
    │   │   └── single.html
    │   └── shortcodes
    │       ├── codecaption.html
    │       └── imgcap.html
    ├── sample-config.toml
    ├── static
    │   ├── css
    │   │   └── hugo-octopress.css
    │   └── favicon.png
    └── theme.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;지금 개발하고 있는 사이트 프로젝트 폴더 밑으로 &lt;code&gt;layouts&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;archetypes&lt;/code&gt;가 있듯이 테마도 같은 구조를 가지고 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;정적-리소스를-교체하는-법&#34;&gt;정적 리소스를 교체하는 법&lt;/h2&gt;

&lt;p&gt;테마에 따라온 jQuery버전이 맘에 안 드시나요? 교체하는 법은 기존의 것은 그대로 두고 새로운 jQuery버전을 다운로드 받아 테마에 위치한 장소와 같은 상대적 경로에 배치하면 Hugo는 테마의 jQuery를 사용하지 않고 프로젝트에 배치된 것을 사용해서 사이트를 구축합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테마 밑&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/themes/themename/static/js/jquery.min.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;프로젝트 Root&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/static/js/jquery.min.js
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;템플릿-교체하는-법&#34;&gt;템플릿 교체하는 법&lt;/h2&gt;

&lt;p&gt;Hugo는 탬플릿을 찾을 때 항상 프로젝트 밑 &lt;code&gt;layouts&lt;/code&gt;폴더를 먼저 검색하고 없으면 테마의 &lt;code&gt;layouts&lt;/code&gt;을 찾아봅니다. 이런 Hugo의 특성을 이용하여 테마의 템프렛을 수정해야 할 필요가 생길 때 &lt;code&gt;layouts&lt;/code&gt;폴더 밑으로 같은 경로와 이름의 템플릿으로 교체하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테마 밑&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/themes/themename/layouts/_default/single.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;프로젝트 Root&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/layouts/_default/single.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;특히 부분 템플릿(partial template)을 잘 활용한 테마의 경우 이런 교체법은 사이트의 보수유지를 최소화하고 미래에도 호환성을 보장하게 해 주는 장점을 가지고 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;archetype-교체하는-법&#34;&gt;archetype 교체하는 법&lt;/h2&gt;

&lt;p&gt;Archetype을 제공하는 테마의 경우 &lt;code&gt;archetypes&lt;/code&gt;폴더로 교체하고자 하는 archetype 파일을 복사한 다음 필요에 맞게 수정하면 됩니다.&lt;/p&gt;

&lt;h2 id=&#34;default-템플릿-사용-주의&#34;&gt;Default 템플릿 사용 주의&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;layouts/_default&lt;/code&gt;폴더내의 템플릿들은 테마에 비슷한 파일들을 가리지 않고 교체하는 효과가 있어 사용을 자제해야 합니다. 항상 default 템플릿을 사용하기 보다는 특정한 템플릿 교체가 더 낫다는 사실을 명심하십시요.&lt;/p&gt;

&lt;h1 id=&#34;새-테마-만들기&#34;&gt;새 테마 만들기&lt;/h1&gt;

&lt;p&gt;새로 테마를 만들기 위한 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new theme golangkorea
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 &lt;code&gt;themes&lt;/code&gt;폴더 안에 다음과 같이 테마구조를 발생시킵니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;golangkorea
├── LICENSE.md
├── archetypes
│   └── default.md
├── layouts
│   ├── 404.html
│   ├── _default
│   │   ├── list.html
│   │   └── single.html
│   ├── index.html
│   └── partials
│       ├── footer.html
│       └── header.html
├── static
│   ├── css
│   └── js
└── theme.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;템플릿은 Go의 템플릿 언어로 만들어 집니다. &lt;a href=&#34;https://gohugo.io/layout/go-templates/&#34;&gt;Go template primer&lt;/a&gt;은 Go 템플릿 언어를 숙지하기 위한 좋은 출발점입니다.&lt;/p&gt;

&lt;h2 id=&#34;테마-콤퍼넌트&#34;&gt;테마 콤퍼넌트&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Layouts&lt;/strong&gt; 근본적으로 웹사이트는 두가지 형식의 페이지를 통해 컨텐트를 제공합니다: 컨텐트 자체가 하나의 페이지인 경우와 여러 항목을 나열해 놓은 페이지. Hugo의 테마는 이 두가지 페이지를 처리하는 기본(default) 템플릿에서 시작해서 컨텐트 타입(type)과 section을 통해 추가로 layout을 제공하는 템플릿을 준비합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Single Content&lt;/strong&gt; 기본 템플릿은 &lt;code&gt;layouts/_default/single.html&lt;/code&gt;에 위치합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;List of Contents&lt;/strong&gt; 기본 템플릿은 &lt;code&gt;layouts/_default/list.html&lt;/code&gt;에 위치합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Partial Templates&lt;/strong&gt; 부분 템플릿은 테마 제작에 있어 매우 중요한 요소입니다. 부분 템플릿을 통해 코드 재사용이 가능하고 아주 작은 부분만 교체하거나 삽입할 수 있게 해 주는 메카니즘이어서 테마의 유지보수가 간단해 지고 미래의 호환성을 보장해 줍니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Static&lt;/strong&gt; 테마내 정정 리소스의 구조는 전적으로 개발자에게 달려 있습니다. 보통은 &lt;code&gt;/css&lt;/code&gt;, &lt;code&gt;js&lt;/code&gt;, &lt;code&gt;img&lt;/code&gt;와 같은 폴더를 이용해 정적 자원을 관리합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Archetypes&lt;/strong&gt; 특정한 컨텐트 타입의 정면 변수를 정의하는 archetype을 테마에 포함시킬 수 있습니다. 자세한 내용은 &lt;a href=&#34;https://gohugo.io/content/archetypes/&#34;&gt;Archetype Guideline&lt;/a&gt;을 확인할 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generator meta tag&lt;/strong&gt; 테마 개발자들에게 HTML의 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;에 Generator meta tag, &lt;code&gt;.Hugo.Generator&lt;/code&gt;을 포함시킬 것을 권유합니다. Hugo의 사용과 인기도를 가늠하는데 도움을 줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>시리즈 #2 - 컨텐츠 제작 기초</title>
      <link>https://golangkorea.github.io/post/hugo-intro/content-basic/</link>
      <pubDate>Tue, 23 Aug 2016 23:25:04 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/hugo-intro/content-basic/</guid>
      <description>

&lt;h1 id=&#34;컨텐츠-제작-기초&#34;&gt;컨텐츠 제작 기초&lt;/h1&gt;

&lt;p&gt;컨텐츠를 제작하면서 꼭 알아야 할 몇가지 개념을 정리하겠습니다.&lt;/p&gt;

&lt;h1 id=&#34;컨텐츠의-조직적인-관리-organization&#34;&gt;컨텐츠의 조직적인 관리 (Organization)&lt;/h1&gt;

&lt;p&gt;사이트가 많은 양의 컨텐츠를 보유하게 되면서 조직적인 관리가 필요할 때 Hugo가 어떻게 도와주는지 알아 봅시다. &lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/getting-started/&#34;&gt;시리즈 1&lt;/a&gt;에서 보았 듯이 Hugo의 &lt;code&gt;configuration&lt;/code&gt;&lt;sup&gt;1&lt;/sup&gt;에 특별한 세팅이 없는 한 모든 컨텐츠는 &lt;code&gt;content&lt;/code&gt; 폴더 안에 위치하게 됩니다. Hugo를 통해 만들어질 사이트의 URL은 &lt;code&gt;content&lt;/code&gt;내의 폴더 구조와 매우 밀접한 관계가 있습니다. 우선 &lt;code&gt;content&lt;/code&gt; 바로 아래 위치하는 폴더는 &lt;code&gt;section&lt;/code&gt;이라고 부르는데 매우 중요한 역활을 합니다. 다음의 예는 &lt;code&gt;section&lt;/code&gt;이 사이트 URL과 어떤 상관이 있는지 암시합니다. 만들어진 사이트의 URL경로는 거울을 보듯이 컨텐츠 소스의 경로을 반영합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ascii&#34;&gt;.
|- content
   |- post
   |  |- firstpost.md   // &amp;lt;- http://1.com/post/firstpost/
   |  |- happy
   |  |  |- ness.md     // &amp;lt;- http://1.com/post/happy/ness/
   |  |- secondpost.md  // &amp;lt;- http://1.com/post/secondpost/
   |- quote
      |- first.md       // &amp;lt;- http://1.com/quote/first/
      |- second.md      // &amp;lt;- http://1.com/quote/second/

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그렇다면 컨텐트가 소스의 경로와 다른 URL 경로를 가질 수는 없는 걸까요? 예를 들어,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;파일 이름 보다 좀 더 의미있는 단어가 URL에 나타나게 할 수는 없는가?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;section&lt;/code&gt;을 다른 이름으로 대체할 수는 없는가?&lt;/li&gt;
&lt;li&gt;다른 &lt;code&gt;section&lt;/code&gt;에 속한 컨텐트를 서로 조합해서 일관된 URL로 나타나게 할 수는 없는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 질문들에 대한 답을 얻기 위해서 다음의 개념들을 이해할 필요가 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;컨텐트-경로-destination&#34;&gt;컨텐트 경로 (Destination)&lt;/h1&gt;

&lt;p&gt;이미 살펴본 바와 같이 특별한 변수가 없다면 Hugo를 통해 생성된 컨텐트의 경로는 소스파일의 경로에 의해 결정됩니다. 하지만 컨텐트의 경로는 앞으로 살펴볼 정면 변수들(Front Matter)을 통해 다양한 형태로 조정될 수 있습니다. 그럼 Hugo는 컨텐트의 경로를 어떻게 조립하는 것일까요? 우선 몇가지 경로의 부분을 지칭하는 이름을 소개하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ascii&#34;&gt;            permalink
⊢--------------^-------------⊣
http://spf13.com/projects/hugo

    baseURL       section  slug
⊢-----^--------⊣ ⊢--^---⊣ ⊢-^⊣
http://spf13.com/projects/hugo

    baseURL       section          slug
⊢-----^--------⊣ ⊢--^--⊣        ⊢--^--⊣
http://spf13.com/extras/indexes/example

    baseURL            path       slug
⊢-----^--------⊣ ⊢------^-----⊣ ⊢--^--⊣
http://spf13.com/extras/indexes/example

    baseURL            url
⊢-----^--------⊣ ⊢-----^-----⊣
http://spf13.com/projects/hugo

    baseURL               url
⊢-----^--------⊣ ⊢--------^-----------⊣
http://spf13.com/extras/indexes/example
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;section&lt;/strong&gt; 컨텐트 타입의 기본값을 결정합니다.

&lt;ul&gt;
&lt;li&gt;컨텐트 소스의 위치에 따라 값이 정해집니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;url&lt;/code&gt; 정면변수의 값은 &lt;code&gt;section&lt;/code&gt; 부분경로를 바꿀 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slug&lt;/strong&gt; 확장자를 제외한 컨텐트 소스의 파일 이름으로 정해집니다.

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;slug&lt;/code&gt; 정면변수의 값을 통해 바꿀 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;path&lt;/strong&gt; &lt;code&gt;section&lt;/code&gt;에서 시작하여 &lt;code&gt;slug&lt;/code&gt;직전까지의 경로

&lt;ul&gt;
&lt;li&gt;컨텐트 소스의 경로에 의해 결정됩니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;url&lt;/strong&gt; basicURL 다음부터 &lt;code&gt;slug&lt;/code&gt;까지 포함된 상대적인 URL

&lt;ul&gt;
&lt;li&gt;정면변수에 의해 결정될 수 있으며 컨텐트 경로를 결정하는 다른 정면변수의 영향을 무력화 합니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;slug&lt;/code&gt;나 &lt;code&gt;url&lt;/code&gt; 정면변수들을 통해 컨텐트의 목적지 경로(Destination)를 부분적으로 수정하거나 전면적으로 교체할 수 있다는 걸 알 수 있습니다. 이제 목적지 경로 변경 기능외에 컨텐트 처리와 HTML변환시 정면 변수들이 어떤 역활을 하는지 알아봅시다.&lt;/p&gt;

&lt;h1 id=&#34;정면-변수들-front-matter&#34;&gt;정면 변수들(Front Matter)&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Front Matter&lt;/code&gt;는 컨텐트의 메타 데이터라고 할 수 있습니다. 컨텐트보다 먼저 나타난다는 의미로 &lt;code&gt;front matter&lt;/code&gt;라는 이름을 지었을 것으로 추측해 봅니다. 시작과 끝을 나타내는 문자열에 따라 여러가지 포맷이 지원됩니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+++&lt;/code&gt;로 시작과 끝이 표시되면 &lt;a href=&#34;https://github.com/toml-lang/toml&#34;&gt;TOML&lt;/a&gt;을 사용해 &lt;code&gt;Front Matter&lt;/code&gt;를 정의할 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;---&lt;/code&gt;로 시작과 끝이 표시되면 &lt;a href=&#34;http://yaml.org&#34;&gt;YAML&lt;/a&gt;을 사용해 &lt;code&gt;Front Matter&lt;/code&gt;를 정의할 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{&lt;/code&gt;로 시작하고 &lt;code&gt;}&lt;/code&gt;로 끝이 표시되면 &lt;a href=&#34;http://www.json.org&#34;&gt;JSON&lt;/a&gt;을 사용해 &lt;code&gt;Front Matter&lt;/code&gt;를 정의할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 글에서는 TOML의 예만을 살려보도록 하겠습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2016-08-23T23:25:04-04:00&amp;quot;
draft = true
title = &amp;quot;시리즈 #2 - 컨텐츠 제작 기초&amp;quot;
description = &amp;quot;Hugo 입문 두번째 시리즈로 컨텐츠 제작과 관련해 꼭 알아야 할 개념들을 소개합니다&amp;quot;

tags = [&amp;quot;Blog&amp;quot;, &amp;quot;Hugo&amp;quot;]
categories = [&amp;quot;How-to&amp;quot;]
series = [&amp;quot;Hugo Introduction&amp;quot;]
authors = [&amp;quot;Jhonghee Park&amp;quot;]

toc = true
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Front Matter&lt;/code&gt;로 정의될 수 있는 변수에 특별한 제약사항은 없습니다. 어떤 변수라도 템플렛안에서 &lt;code&gt;.Params.varname&lt;/code&gt;형식으로 접근할 수 있습니다. 템플릿 안에서 변수이름은 항상 소문자로 표현됩니다. 예를 들어 &lt;code&gt;camelCase = true&lt;/code&gt;라고 정의된 변수는 템플릿안에서는 &lt;code&gt;.Params.camelcase&lt;/code&gt;&lt;sup&gt;2&lt;/sup&gt;로 값을 출력할 수 있습니다. 다음은 컨텐트 제작에 필수적인 변수들입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;title&lt;/strong&gt; 컨텐트의 제목&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;description&lt;/strong&gt; 컨텐트에 대한 설명&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;date&lt;/strong&gt; 컨텐츠를 정열할 때 사용할 날짜&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;taxonomies&lt;/strong&gt; 항상 복수형으로 표현되는 분류변수로 위의 예제에 나와있는 &lt;code&gt;tags&lt;/code&gt;, &lt;code&gt;categories&lt;/code&gt;, &lt;code&gt;series&lt;/code&gt;, 그리고 &lt;code&gt;authors&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이외에 다음과 같은 선택적으로 사용할 수 있는 변수들도 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;aliases&lt;/strong&gt; 하나 이상의 이름들이 나열된 정렬(예를 들면 이름을 바꾼 컨텐트가 과거에 사용했던 URL)로 현재의 컨텐트 URL로 리디랙트 되는 별명들. 자세한 내용은 다음 링크를 참조, &lt;a href=&#34;https://gohugo.io/extras/aliases/&#34;&gt;Aliases&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;draft&lt;/strong&gt; 만약 값이 true이면, 컨텐트는 HTML로 만들어 지지 않습니다. 하지만 &amp;ndash;buildDrafts 플래크를 써서 강제할 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;publishdate&lt;/strong&gt; 만약 날짜가 미래로 잡혀 있으면, 컨텐트는 HTML로 변환되지 않습니다. &amp;ndash;buildFuture 플래그를 써서 강제할 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;type&lt;/strong&gt; 컨텐트 타입 (없는 경우는 컨텐트가 속한 디렉토리를 통해 값이 정해집니다. 즉, &lt;code&gt;type&lt;/code&gt;의 기본값은 &lt;code&gt;section&lt;/code&gt;을 통해 정해집니다.)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;isCJKLanguage&lt;/strong&gt; 값이 true인 경우, 컨텐트를 한중일 언어로 작성된 것으로 간주하고, &lt;code&gt;.Summary&lt;/code&gt;와 &lt;code&gt;WordCount&lt;/code&gt;와 같은 값들이 한중일 언어에 맞게 생성됩니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;weight&lt;/strong&gt; 컨텐트의 차례를 정렬하는데 사용됩니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;markup&lt;/strong&gt; (실험적변수) &lt;code&gt;rst&lt;/code&gt;는 reStructuredText (rst2html 툴을 사용합니다) or &lt;code&gt;md&lt;/code&gt; (기본값) 은 Markdown&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slug&lt;/strong&gt; URL의 말단에 위치하는 토큰(token)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;url&lt;/strong&gt; 웹 루트에서 컨텐트까지의 전체 경로.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사이트 개발자의 입장에서 사이트의 기능을 확장하고 컨텐트 제작자에게 그 기능을 조종할 수 있는 인터페이스를 제공하려고 할 때 정면 변수를 유용하게 사용할 수 있습니다. 위에 정면변수 예를 보면, 렌더링된 컨텐트의 상단에 목차를 구현하고 그 기능을 컨텐트 제작시 &lt;code&gt;toc = true&lt;/code&gt;를 이용해 나타나게 하는 예가 있습니다. 또 다른 예는 &lt;code&gt;authors&lt;/code&gt;를 분류변수(taxonomies)로 등록하고 테마를 통해 구현한 뒤 정면변수의 하나로 컨텐트 제작자에게 자신의 이름을 입력할 수 있게 합니다. 컨텐츠 제작자는 항상 동일한 이름을 사용함으로서 사이트가 제공하는 컨텐츠 목록의 자동 발생을 사용할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;지원되는-컨텐트의-포맷&#34;&gt;지원되는 컨텐트의 포맷&lt;/h1&gt;

&lt;p&gt;컨텐트 상단에 정면변수들의 정의되고 그 뒤로 컨텐트의 내용이 따라옵니다. Hugo의 컨텐트는 다양한 포맷으로 제작될 수 있습니다. &lt;a href=&#34;http://www.methods.co.nz/asciidoc/&#34;&gt;asciidoc&lt;/a&gt;, &lt;a href=&#34;http://docutils.sourceforge.net/rst.html&#34;&gt;reStructuredText&lt;/a&gt;는 외부 프로그램의 도움을 얻어 지원되는 포맷들입니다. 외부 툴에 의존하지 않고 Hugo 자체적으로 컨텐트를 제작할 수 있는 포맷은 &lt;a href=&#34;https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet&#34;&gt;Markdown&lt;/a&gt;입니다. Markdown을 이용해 새로운 컨텐트를 제작하고 싶으면 &lt;code&gt;hugo new&lt;/code&gt;명령에 &lt;code&gt;md&lt;/code&gt;확장자를 가지는 파일이름을 사용해 시작할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new post/my-first-blog.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령이 실행되면 Markdown 파일이 만들어 지고 기본적인 정면변수들의 셑업이 이루어 집니다. 이 Scaffolding 과정에서 Hugo는 post라는 archetype을 찾기 위해 테마의 archetypes 폴더나 프로젝트 내 archetypes 폴더안을 검색하고 정면변수들의 기본 셑업을 진행합니다. 만약에 post archetype이 정의되어 있지 않을 때는 Hugo의 기본 값들을 사용합니다.&lt;/p&gt;

&lt;h1 id=&#34;컨텐트-타입과-전형-content-types-and-archetypes&#34;&gt;컨텐트 타입과 전형 (Content Types and archetypes)&lt;/h1&gt;

&lt;p&gt;컨텐트 타입은 기본적으로 소스의 위치가 어디에 있느냐에 따라 결정 됩니다. &lt;code&gt;post/my-first-blog.md&lt;/code&gt;에 작성된 컨텐트는 정면변수 &lt;code&gt;type&lt;/code&gt;이 존재하지 않는 한 post 컨텐트 타입으로 간주되어 타입에 맞는 렌더링이 이루어 집니다. 만약에 전혀 새로운 컨텐트 타입을 도입하고자 하면 어떻게 해야 할까요? 예를 들어 musician이라는 컨텐트 타입을 통해 유명한 음악가들의 소개를 하고자 하는 가정을 합시다. &lt;code&gt;hugo new musician/bach.md&lt;/code&gt;로 컨텐트를 초기화 했을때 Hugo의 입장에서는 musician이라는 컨텐트 타입으로 bach.md의 HTML을 렌더링하려고 할 것입니다. musician 컨텐트에 특화된 렌더링을 제공하려면 다음과 같이 새로운 탬플릿을 layouts에 추가해야 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;우선 컨텐트 자체의 렌더링을 위해 &lt;code&gt;layouts/musician/single.html&lt;/code&gt;을 추가합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;section&lt;/code&gt; 리스트 페이지의 렌더링을 지원하기 위해서는 &lt;code&gt;layouts/section/musician.html&lt;/code&gt;을 추가합니다.&lt;/li&gt;
&lt;li&gt;음악가의 시대에 따라 조금씩 다른 페이지 뷰(View)를 제공하려면 &lt;code&gt;layouts/musician&lt;/code&gt;안에 변형된 템플릿을 추가하고 컨텐트의 정면변수로 &lt;code&gt;layout&lt;/code&gt;을 사용해 지정해 줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;템플릿을 준비하면서 musician 컨텐트 타입에 필요한 새로운 정면변수들이 생길 수 있습니다. 저자의 입장에서는 새로운 musician 컨텐트를 &lt;code&gt;hugo new&lt;/code&gt;명령으로 발생 시킨 후 첨가된 정면변수들을 일일이 &lt;strong&gt;기억&lt;/strong&gt;해서 입력해야 하는 불편함이 생깁니다. 이런 불편함을 해소하기 위해 musician 컨텐트 타입의 전형(archetype)을 정의해 줄 필요가 있습니다. musician archetype은 &lt;code&gt;archetypes/musician.md&lt;/code&gt;를 사용해 정의되고 이 archetype 문서에 필요한 기본값들을 지정해 줄 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;archetypes/musician.md&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
name = &amp;quot;&amp;quot;
bio = &amp;quot;&amp;quot;
genre = &amp;quot;&amp;quot;
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 archetype을 사용해 새 musician 컨텐트를 만들어 봅시다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new musician/mozart.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hugo는 musician 타입을 인지하고 준비된 archetype을 이용하여 정면변수들을 자동으로 입력해 줍니다.
&lt;strong&gt;content/musician/mozart.md&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
title = &amp;quot;mozart&amp;quot;
date = &amp;quot;2015-08-24T13:04:37+02:00&amp;quot;
name = &amp;quot;&amp;quot;
bio = &amp;quot;&amp;quot;
genre = &amp;quot;&amp;quot;
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;컨텐츠 저자의 관점에서 보면 이제 어느 정도 Hugo를 이용해 정적사이트를 건설할 준비가 끝난 셈입니다. 이어지는 시리즈에서는 사이트 개발자의 관점에서 어떻게 새로운 테마를 만들 수 있는지, 정면변수들과 사이트 구성변수(configuration)들이 템플릿안에서 어떻게 접근할 수 있는지를 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;br/&gt;
  &lt;ol&gt;
    &lt;li&gt;Hugo의 configuration은 특별한 조치가 없는 경우 프로젝트 폴더내 config.toml에 정의됩니다. TOML외 YAML과 JSON 포맷이 지원됩니다.&lt;/li&gt;
    &lt;li&gt;Hugo는 여러 템플릿 엔진을 지원합니다. 이 글에서는 Go언어의 자체적 &lt;code&gt;text/template&lt;/code&gt;을 사용하는 것을 전제합니다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>시리즈 #1 - Hugo 시작하기</title>
      <link>https://golangkorea.github.io/post/hugo-intro/getting-started/</link>
      <pubDate>Tue, 23 Aug 2016 23:24:55 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/hugo-intro/getting-started/</guid>
      <description>

&lt;h1 id=&#34;hugo-시작하기&#34;&gt;Hugo 시작하기&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt;는 Go로 제작되고 하나의 실행파일로 배포됩니다. 다양한 설치 방법이 있지만 우선 Package Manager를 쓰시는 분들을 중심으로 살펴보겠습니다.&lt;/p&gt;

&lt;h2 id=&#34;package-manager로-설치하기&#34;&gt;Package Manager로 설치하기&lt;/h2&gt;

&lt;p&gt;MacOS를 쓰시는 분들은 Homebrew를 이용해 쉽게 설치하실 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew update &amp;amp;&amp;amp; brew install hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Windows에서 Chocolatey를 쓰시는 분들도 비슷한 방법으로 설치가 가능합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\&amp;gt; choco install hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linux에서는 조금 복잡해 집니다. 우분트를 쓰시는 분들은 우선 &lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;Hugo 릴리즈 페이지&lt;/a&gt;로 가서 최신 deb 버전을 다운로드한 후에 다음 명령을 실행 시키면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dpkg -i hugo*.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;소스로-직접-빌드해-쓰는-방법&#34;&gt;소스로 직접 빌드해 쓰는 방법&lt;/h2&gt;

&lt;p&gt;이미 Go로 개발 환경을 갖추고 계신 분들은 직접 소스를 빌드해 쓰시는 방법이 가장 편합니다. 간단히 &lt;code&gt;go get&lt;/code&gt;툴을 이용해 설치하실 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go get -v github.com/spf13/hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hugo가 설치되었는지를 &lt;code&gt;version&lt;/code&gt; 보조 명령어를 사용해 확인하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo version
Hugo Static Site Generator v0.17-DEV BuildDate: 2016-08-21T19:44:40-04:00
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;프로젝트-폴더-만들기&#34;&gt;프로젝트 폴더 만들기&lt;/h1&gt;

&lt;p&gt;정적 사이트 제너레이터를 처음 접하시는 분들을 위해 Hugo를 간단하게 설명하자면, Hugo는 소스 폴더 아래 존재하는 파일과 컨텐츠 템플릿을 입력으로 사용해서 웹사이트 전체를 출력하는 시스템입니다. 보통 소스는 &lt;a href=&#34;https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet&#34;&gt;Markdown&lt;/a&gt;을 이용한 컨텐츠이거나 템플릿 언어로 작성된 HTML에 자바스크립과 CSS스타일로 구성되어 웹 개발자에게 매우 친숙한 환경이라 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ascii&#34;&gt;  +------------------+
  |    Content       +--------+
  |    (Markdown)    |        |
  +------------------+        |           +------------+
  +------------------+     +--v---+       |Full Website|
  |Template          |     |      |       +-------+----+
  |(text/template)   |     | Hugo |       |       |    |
  |(Ace)             +-----&amp;gt;      +-------&amp;gt;       |    |
  |(Amber)           |     |      |       |       |    |
  +------------------+     +--^--^+       |       |    |
  +------------------+        |  |        |       |    |
  |Configuraton      |        |  |        +-------+----+
  |(toml, yaml, json)+--------+  |
  +------------------+           |
  +------------------+           |
  | Static           |           |
  | (image)          |           |
  | (javascript)     +-----------+
  | (css)            |
  +------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hugo는 커맨드라인 명령어 체계는 각종 보조 명령어와 POSIX를 준수하는 플래그로 구성되어 빌드와 유틸리티 기능을 제공합니다. 우선 Hugo가 제공하는 Scaffolding 명령어를 가지고 프로젝트 폴더를 만들어 보도록 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new site golangkorea-hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hugo의 모든 명령&lt;a href=&#34;#footnote-1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;은 &lt;code&gt;hugo&lt;/code&gt;로 시작하고 보조 명령어가 뒤를 따릅니다. 여기서 &lt;code&gt;new&lt;/code&gt;는 보조 명령어로서 &lt;code&gt;site&lt;/code&gt; 보조 명령어와 함께 프로젝트를 초기화합니다. 초기화된 프로젝트의 폴더 구조는 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd golangkorea-hugo
$ tree -a
.
├── archetypes
├── config.toml
├── content
├── data
├── layouts
├── static
└── themes

6 directories, 1 file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;초기화된 프로젝트에는 텅빈 폴더 6개와 &lt;code&gt;config.toml&lt;/code&gt; 파일 하나가 만들어 집니다. 각 폴더의 용도를 간단히 나열하면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;archetypes: &lt;code&gt;hugo new&lt;/code&gt;명령으로 컨텐트 생성시 &lt;a href=&#34;https://gohugo.io/content/front-matter/&#34;&gt;Front Matter&lt;/a&gt;&lt;a href=&#34;#footnote-2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; 에 컨텐트 타입에 따른 기본 값들을 어떻게 정해줄 것인가를 결정하는 파일들을 저장합니다.&lt;/li&gt;
&lt;li&gt;content: 컨텐츠가 저장됩니다.&lt;/li&gt;
&lt;li&gt;data: 템플랫으로 불러쓸 수 있는 데이터 파일을 저장하는 공간입니다. 데이터의 타입은 toml, yaml, 과 json이 지원됩니다.&lt;/li&gt;
&lt;li&gt;layouts: 테마를 커스터마이징할 때 기존의 테마내 탬플릿의 내용을 수정하거나 덧씌우기를 하는 템플릿을 저장하는 공간입니다.&lt;/li&gt;
&lt;li&gt;static: 이미지, 자바스크립, CSS등을 저장하는 공간&lt;/li&gt;
&lt;li&gt;themes: 사이트의 테마를 저장하는 공간.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;config.toml의 내용을 보면 다음과 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;baseurl = &amp;quot;http://replace-this-with-your-hugo-site.com/&amp;quot;
languageCode = &amp;quot;en-us&amp;quot;
title = &amp;quot;My New Hugo Site&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;baseurl&lt;/code&gt;은 말 그대로 사이트내 모든 리소스의 URL의 베이스를 형성합니다. 예를 들어 &lt;code&gt;content/post/my-first-blog.md&lt;/code&gt;라는 컨텐트가 있으면 Full URL은 &lt;code&gt;http://replace-this-with-your-hugo-site.com/post/my-first-blog&lt;/code&gt;이 됩니다.&lt;/p&gt;

&lt;h1 id=&#34;첫번째-컨텐트-만들기&#34;&gt;첫번째 컨텐트 만들기&lt;/h1&gt;

&lt;p&gt;그럼, 다음 Scaffolding 명령을 써서 첫번째 블로그 포스트를 만들어 보도록 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new post/my-first-blog.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;content/post/my-first-blog.md&lt;/code&gt;가 만들어 지면 아래와 같이 편집을 하고 저장하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2016-08-24T21:51:10-04:00&amp;quot;
draft = true
title = &amp;quot;my first blog&amp;quot;

+++

# Hello, Hugo! &amp;lt;- 편집 부분
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hugo server&lt;/code&gt;명령을 써서 Hugo가 제공하는 웹서버를 구동한 다음 &lt;code&gt;http://localhost:1313&lt;/code&gt;을 브라우저로 열어 보십시요. 텅빈 페이지로 나타날 겁니다. 왜 그럴까요? 답 부터 말씀드리면 Hugo의 입장에서는 무엇으로 페이지를 렌더링할 지 아무런 정보가 없는 경우인 것입니다. &lt;code&gt;layouts&lt;/code&gt; 폴더안에 &lt;code&gt;index.html&lt;/code&gt;이라는 파일을 만들고 다음과 같이 편집해 저장하신 다음 다시 &lt;code&gt;http://localhost:1313&lt;/code&gt;을 열어 보십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;Hello, Hugo!&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Hello, Hugo!&lt;/strong&gt;라고 크게 나타나는 것을 보게 될 것입니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;http://localhost:1313/post/my-first-blog&lt;/code&gt;를 열어 보십시요. 심지어 &lt;code&gt;404 page not found&lt;/code&gt;라고 나옵니다. 텅빈 페이지가 아니고 왜 404일까요? 이유는 포스트의 Front Matter에 &lt;code&gt;draft = true&lt;/code&gt;라고 명시되어 있어서 Hugo의 입장에서는 렌더링을 할 이유가 없는 것이죠. &lt;code&gt;Ctrl-C&lt;/code&gt;로 Hugo 웹서버를 중단시킨 다음 &lt;code&gt;hugo server -D=true&lt;/code&gt;명령을 써서 다시 웹서버를 가동시키시고 &lt;code&gt;http://localhost:1313/post/my-first-blog&lt;/code&gt;를 열어 보십시요. 이번에는 404가 아니고 텅빈 페이지가 보일 겁니다. Hugo를 의인화해서 다시 설명을 드리면, &lt;code&gt;-D=true&lt;/code&gt; 플래그를 보고 드래프트 포스트도 렌더링을 해야 하는데 어떻게 해야 할 지 몰라 백지를 낸 상황인 겁니다. 이건 어떻게 고쳐야 할까요?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;layouts/post/single.html&lt;/code&gt;라는 파일을 만드시고 다음의 내용을 저장하신 다음, &lt;code&gt;http://localhost:1313/post/my-first-blog&lt;/code&gt;을 열어 보세요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;Before content&amp;lt;/p&amp;gt;
{{ .Content }}
&amp;lt;p&amp;gt;After content&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;첫번째 포스트가 이제 보이십니까?&lt;/p&gt;

&lt;h1 id=&#34;이렇게-힘들게-만들어야-하나&#34;&gt;이렇게 힘들게 만들어야 하나?&lt;/h1&gt;

&lt;p&gt;이런 질문이 당연히 생기실 겁니다. 사이트의 구조와 컨텐츠의 템플릿을 하나씩 만들어 나가야 한다면 사이트 발생기라고 부를 이유가 없겠죠. 누군가 그런 힘든 노동을 통해 &lt;code&gt;layouts&lt;/code&gt;의 구조와 템플랫을 모두 작성했다면 공유할 수 있는 메카니즘이 필요합니다. 그런 공유의 매카니즘을 &lt;code&gt;테마(theme)&lt;/code&gt;이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;layouts/index.html&lt;/code&gt;과 &lt;code&gt;layouts/post/single.html&lt;/code&gt;을 제거하시고 테마를 사용하는 방법을 배워 봅시다. 다음과 같이 &lt;code&gt;hugo-octopress&lt;/code&gt; 테마를 설치하십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm layouts/index.html
$ rm layouts/post/single.html
$ cd themes
$ git clone https://github.com/parsiya/Hugo-Octopress.git
$ cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;테마가 설치된 후에는 Hugo의 웹서버를 다음과 같이 시작해 보십시요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server -D=true -t=hugo-octopress
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hugo로 만든 당신의 첫번째 포스트가 보일 겁니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/211484/17955233/9990f3c8-6a4e-11e6-8d3e-0c824453ba1f.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;ol&gt;
  &lt;li&gt;&lt;a id=&#34;footnote-1&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://gohugo.io/commands/&#34;&gt;Hugo의 모든 명령&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a id=&#34;footnote-2&#34;&gt;&lt;/a&gt;컨텐트 인스턴스의 메타데이터로 템플릿에서 호출해 쓸 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo 입문 - 개요</title>
      <link>https://golangkorea.github.io/post/hugo-intro/overview/</link>
      <pubDate>Tue, 23 Aug 2016 22:35:57 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/hugo-intro/overview/</guid>
      <description>&lt;p&gt;Hugo는 현존하는 가장 빠른 정적 사이트 제너레이터(Static Site Generator)로 알려져 있습니다. 기능적인 측면에서도 여타 동적 사이트 제너레이터(Static Site Generator)에 비해 손색이 없을 뿐더러 설치가 간편하고 Go언어에 친숙한 개발자들에게는 최고의 컨텐츠 제작 환경을 제공한다고 생각합니다. &lt;a href=&#34;https://golangkorea.github.io&#34;&gt;Golang Korean Community&lt;/a&gt; 사이트도 Hugo로 제작되고 있습니다. &lt;strong&gt;Hugo 입문&lt;/strong&gt; 시리즈를 통해 이 사이트에 기여하시고자 하는 분들에게 가이드라인을 제공할 뿐만 아니라 자신만의 블로그 사이트를 쉽게 제작하고자 하는 분들에게도 도움이 되길 기원하는 마음으로 시리즈를 준비했습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/getting-started/&#34;&gt;Hugo 시작하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/content-basic/&#34;&gt;컨텐츠 제작 기초&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/theme-customizing/&#34;&gt;사이트 테마 커스터마이징 하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/taxonomy-basic/&#34;&gt;분류(Taxonomy)기능 사용하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/how-to-contribute-content/&#34;&gt;사이트에 블로그 올리는 방법&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ReadMe First</title>
      <link>https://golangkorea.github.io/post/readme-first/</link>
      <pubDate>Fri, 19 Aug 2016 23:35:49 -0400</pubDate>
      
      <guid>https://golangkorea.github.io/post/readme-first/</guid>
      <description>

&lt;h1 id=&#34;the-slow-hunch&#34;&gt;The Slow Hunch&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/Where-Good-Ideas-Come-Innovation/dp/1594487715&#34;&gt;Where Good Ideas Come From: The Natural History of Innovation&lt;/a&gt;의 저자 Steven B. Johnson에 따르면 인류의 역사를 바꾼 혁신들은 번뜩이는 아이디어에서 시작된 경우가 매우 드물다고 합니다. 대개는 개개인의 작은 아이디어들이 오랜 시간에 걸쳐 다른 사람이 갖고 있는 비슷하거나 전혀 다른 아이디어들과 충돌하고 결합하면서 커뮤니티의 지능으로 진화하고 어느 순간 돌이킬 수 없는 변화의 모멘텀을 형성하며 세상을 바꿉니다. 커뮤니티내에 공유되고 있는 지능이 다시 역으로 개개인에게 영감과 비젼을 제시하는 상호작용을 일으키게 되는데 그런 과정은 통해 아이디어의 생산을 가능케하는 현상을 slow hunch라고 부릅니다.&lt;/p&gt;

&lt;p&gt;새로 시작하는 Golang Korean 커뮤니티 웹사이트(이하 GoSudaWeb)은 프로그래밍 언어인 Go와 퉅들, 글로벌 개발자 커뮤니티내의 트랜드와 최선의 개발방식에 대한 소개를 블로그와 뉴스레터의 형식을 통해 공유하고자 첫발을 내딛었습니다. 지속적인 지식의 축적과 폭 넗은 공유가 이루어지는 웹사이트로 성장하여 미래의 킬러앱과 킬러 아이디어를 만들어내는 slow hunch에 기여할 수 있기를 기대해 봅니다. 많은 성원 부탁드립니다.&lt;/p&gt;

&lt;h1 id=&#34;콘텐트-제작-및-웹사이트-개발-참여-신청&#34;&gt;콘텐트 제작 및 웹사이트 개발 참여 신청&lt;/h1&gt;

&lt;p&gt;GosudaWeb은 &lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Page&lt;/a&gt;로 제작되고 모든 소스와 제작과정이 공개로 이루어 집니다: &lt;a href=&#34;https://github.com/golangkorea&#34;&gt;https://github.com/golangkorea&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;사이트에 포스트하기를 원하시는 분들은 &lt;a href=&#34;https://golangkorea.github.io/post/hugo-intro/how-to-contribute-content/&#34;&gt;사이트에 블로그 올리는 방법&lt;/a&gt;을 참조하시길 바랍니다.&lt;/p&gt;

&lt;p&gt;Hugo를 이용해 사이트 개발에 참여하거나 golangkorea Organization에 오픈소스 프로젝트를 시작하시고 싶으신 분들은 멤버 신청을 하실 수 있습니다. 멤버 신청은 &lt;a href=&#34;mailto:golanginkorea@gmail.com&#34;&gt;golanginkorea@gmail.com&lt;/a&gt; 이나 &lt;a href=&#34;https://gitter.im/golang-korean-community/Lobby?utm_source=share-link&amp;amp;utm_medium=link&amp;amp;utm_campaign=share-link&#34;&gt;Golang Korean Community / Lobby&lt;/a&gt;로 해 주시면 됩니다. 일단 멤버로 등록되면 &lt;a href=&#34;https://github.com/orgs/golangkorea/teams/golangkorea-website&#34;&gt;golangkorea-website team&lt;/a&gt;을 통해 개발에 참여하실 수 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;토론방&#34;&gt;토론방&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://golangkorea.github.io&#34;&gt;golangkorea.github.io&lt;/a&gt; 개발, 유지 보수 및 지원에 대한 토론은 &lt;a href=&#34;https://gitter.im/golang-korean-community/golangkorea.github.io?utm_source=share-link&amp;amp;utm_medium=link&amp;amp;utm_campaign=share-link&#34;&gt;Gitter Room&lt;/a&gt;을 통해 하고 있으니 많은 동참 바라겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>